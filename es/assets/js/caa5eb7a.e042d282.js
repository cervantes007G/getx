"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[129],{7435:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>t,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=n(5893),o=n(1151);const r={sidebar_position:1},i="Estado",l={id:"pillars/state-management",title:"Estado",description:"GetX no usa Streams o ChangeNotifier como otros administradores de estado. \xbfPor qu\xe9? Adem\xe1s de crear aplicaciones para android, iOS, web, ventanas, macos y linux, con GetX puede construir aplicaciones de servidor con la misma sintaxis que Flutter/GetX. Para mejorar el tiempo de respuesta y reducir el consumo de RAM, creamos GetValue y GetStream, que son soluciones de baja latencia que ofrecen un gran rendimiento, a un bajo costo operativo. Utilizamos esta base para construir todos nuestros recursos, incluida la gesti\xf3n estatal.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/pillars/state-management.md",sourceDirName:"pillars",slug:"/pillars/state-management",permalink:"/getx/es/docs/pillars/state-management",draft:!1,unlisted:!1,editUrl:"https://github.com/jonataslaw/getx/docs/pillars/state-management.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"The 3 Pillars",permalink:"/getx/es/docs/category/the-3-pillars"},next:{title:"Ruta",permalink:"/getx/es/docs/pillars/route-management"}},t={},d=[{value:"Gestor de estado reactivo",id:"gestor-de-estado-reactivo",level:2},{value:"Ventajas",id:"ventajas",level:3},{value:"M\xe1ximo rendimiento:",id:"m\xe1ximo-rendimiento",level:3},{value:"Declarando una variable reactiva",id:"declarando-una-variable-reactiva",level:3},{value:"Tener un estado reactivo es f\xe1cil.",id:"tener-un-estado-reactivo-es-f\xe1cil",level:5},{value:"Usar los valores en la vista",id:"usar-los-valores-en-la-vista",level:3},{value:"Condiciones para reconstruir",id:"condiciones-para-reconstruir",level:3},{value:"Donde .obs pueden ser usados",id:"donde-obs-pueden-ser-usados",level:3},{value:"Nota sobre listas",id:"nota-sobre-listas",level:3},{value:"\xbfPor qu\xe9 tengo que usar .value",id:"por-qu\xe9-tengo-que-usar-value",level:3},{value:"Obx()",id:"obx",level:3},{value:"Trabajadores",id:"trabajadores",level:3},{value:"Gestor de Estado simple",id:"gestor-de-estado-simple",level:2},{value:"Ventajas",id:"ventajas-1",level:3},{value:"Uso",id:"uso",level:3},{value:"C\xf3mo maneja los controladores",id:"c\xf3mo-maneja-los-controladores",level:3},{value:"Ya no necesitar\xe1s StatefulWidgets",id:"ya-no-necesitar\xe1s-statefulwidgets",level:3},{value:"Por qu\xe9 existe",id:"por-qu\xe9-existe",level:3},{value:"Otras formas de usarlo",id:"otras-formas-de-usarlo",level:3},{value:"IDs \xfanicos",id:"ids-\xfanicos",level:3},{value:"Mezclar los dos administradores estatales",id:"mezclar-los-dos-administradores-estatales",level:2},{value:"Mixin de estado",id:"mixin-de-estado",level:2},{value:"GetBuilder vs GetX vs Obx vs MixinBuilder",id:"getbuilder-vs-getx-vs-obx-vs-mixinbuilder",level:2}];function c(e){const a={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"estado",children:"Estado"}),"\n",(0,s.jsx)(a.p,{children:"GetX no usa Streams o ChangeNotifier como otros administradores de estado. \xbfPor qu\xe9? Adem\xe1s de crear aplicaciones para android, iOS, web, ventanas, macos y linux, con GetX puede construir aplicaciones de servidor con la misma sintaxis que Flutter/GetX. Para mejorar el tiempo de respuesta y reducir el consumo de RAM, creamos GetValue y GetStream, que son soluciones de baja latencia que ofrecen un gran rendimiento, a un bajo costo operativo. Utilizamos esta base para construir todos nuestros recursos, incluida la gesti\xf3n estatal."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.em,{children:"Complexity"}),": Algunos administradores estatales son complejos y tienen un mont\xf3n de boilerplate. Con GetX no tienes que definir una clase para cada evento, el c\xf3digo es muy limpio y claro, y usted hace mucho m\xe1s escribiendo menos. Muchas personas han renunciado a Flutter por este tema y ahora finalmente tienen una soluci\xf3n absurdamente sencilla para la gesti\xf3n de los Estados."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.em,{children:"Sin generadores de c\xf3digo"}),": Pasa la mitad de su tiempo de desarrollo escribiendo la l\xf3gica de su aplicaci\xf3n. Algunos administradores de estado conf\xedan en que los generadores de c\xf3digo tengan c\xf3digo m\xednimamente legible. Cambiar una variable y tener que ejecutar build_runner puede ser improductivo, y a menudo el tiempo de espera despu\xe9s de un polvo limpio ser\xe1 largo, y usted tendr\xe1 que beber un mont\xf3n de caf\xe9."]}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"Con GetX todo es reactivo, y nada depende de generadores de c\xf3digo, aumentando su productividad en todos los aspectos de su desarrollo."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.em,{children:"No depende del contexto"}),": Probablemente ya necesites enviar el contexto de tu vista a un controlador, hacer que la vista se acople a su l\xf3gica de negocio alto. Probablemente haya tenido que usar una dependencia para un lugar que no tiene contexto, y tuvo que pasar el contexto a trav\xe9s de varias clases y funciones. Esto no existe con GetX. Usted tiene acceso a sus controladores desde dentro de sus controladores sin ning\xfan contexto. No necesita enviar el contexto por par\xe1metro para literalmente nada."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.em,{children:"Control granular"}),": la mayor\xeda de los administradores de estados se basan en ChangeNotifier. CambiarNotificador notificar\xe1 todos los widgets que dependen de ellos cuando se llama a notificarListeners. Si tienes 40 widgets en una pantalla, que tienen una variable de tu clase ChangeNotificfier al actualizar uno, todos ellos ser\xe1n reconstruidos."]}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"Con GetX, incluso los widgets anidados son respetados. Si tienes Obx viendo tu vista de lista, y otra viendo una casilla dentro de la vista de lista, al cambiar el valor de la casilla de verificaci\xf3n, s\xf3lo se actualizar\xe1 cuando se cambie el valor de la lista, s\xf3lo se actualizar\xe1 la vista de lista."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.em,{children:"S\xf3lo reconstruye si su variable cambia REGISTRAMENTE"}),": GetX tiene control de flujo, lo que significa que si muestra un texto con 'Paola', si cambia la variable observable a 'Paola' de nuevo, el widget no ser\xe1 reconstruido. Esto se debe a que GetX sabe que 'Paola' ya se muestra en Texto, y no har\xe1 reconstrucciones innecesarias."]}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"La mayor\xeda (si no todos) los administradores de estado actuales se reconstruir\xe1n en la pantalla."}),"\n",(0,s.jsx)(a.h2,{id:"gestor-de-estado-reactivo",children:"Gestor de estado reactivo"}),"\n",(0,s.jsx)(a.p,{children:"La programaci\xf3n reactiva puede alienar a mucha gente porque se dice que es complicada. GetX convierte la programaci\xf3n reactiva en algo bastante simple:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"No necesitar\xe1 crear StreamControllers."}),"\n",(0,s.jsx)(a.li,{children:"No necesitar\xe1 crear un StreamBuilder para cada variable"}),"\n",(0,s.jsx)(a.li,{children:"No necesitar\xe1 crear una clase para cada estado."}),"\n",(0,s.jsx)(a.li,{children:"No necesitar\xe1 crear un get para un valor inicial."}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"Programaci\xf3n reactiva con Get es tan f\xe1cil como usar setState."}),"\n",(0,s.jsx)(a.p,{children:"Imaginemos que tienes una variable de nombre y queremos que cada vez que la cambies, todos los widgets que la usan se cambien autom\xe1ticamente."}),"\n",(0,s.jsx)(a.p,{children:"Esta es tu variable de contador:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"var name = 'Jonatas Borges';\n"})}),"\n",(0,s.jsx)(a.p,{children:'Para hacerla observable, s\xf3lo tienes que a\xf1adir ".obs" al final de la misma:'}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"var name = 'Jonatas Borges'.obs;\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Eso es todo. Es ",(0,s.jsx)(a.em,{children:"es"})," simple."]}),"\n",(0,s.jsxs)(a.p,{children:['A partir de ahora, podr\xedamos referirnos a esta variable reactiva-".obs"(ervables) como ',(0,s.jsx)(a.em,{children:"Rx"}),"."]}),"\n",(0,s.jsxs)(a.p,{children:["\xbfQu\xe9 hicimos bajo el cap\xf3? Hemos creado un ",(0,s.jsx)(a.code,{children:"Stream"})," de ",(0,s.jsx)(a.code,{children:"String"})," s, asignado el valor inicial ",(0,s.jsx)(a.code,{children:'"Jonatas Borges"'})," , notificamos a todos los widgets que usan ",(0,s.jsx)(a.code,{children:'"Jonatas Borges"'}),' que ahora "pertenecen" a esta variable, y cuando el valor ',(0,s.jsx)(a.em,{children:"Rx"})," cambie, tambi\xe9n tendr\xe1n que cambiar."]}),"\n",(0,s.jsxs)(a.p,{children:["Esta es la ",(0,s.jsx)(a.strong,{children:"magia de GetX"}),", gracias a las capacidades de Dart."]}),"\n",(0,s.jsxs)(a.p,{children:["Pero, como sabemos, un ",(0,s.jsx)(a.code,{children:"Widget"}),' s\xf3lo puede ser cambiado si est\xe1 dentro de una funci\xf3n, porque las clases est\xe1ticas no tienen el poder de "cambio autom\xe1tico".']}),"\n",(0,s.jsxs)(a.p,{children:["Necesitar\xe1s crear un ",(0,s.jsx)(a.code,{children:"StreamBuilder"}),' , suscribirte a esta variable para escuchar los cambios, y crea una "cascada" de ',(0,s.jsx)(a.code,{children:"StreamBuilder"})," anidado si quieres cambiar varias variables en el mismo \xe1mbito, \xbfverdad?"]}),"\n",(0,s.jsxs)(a.p,{children:["No, no necesitas un ",(0,s.jsx)(a.code,{children:"StreamBuilder"})," , pero tienes raz\xf3n sobre las clases est\xe1ticas."]}),"\n",(0,s.jsxs)(a.p,{children:["Bueno, en la vista, normalmente tenemos un mont\xf3n de boilerplate cuando queremos cambiar un Widget espec\xedfico, esa es la manera de Flutter.\nCon ",(0,s.jsx)(a.strong,{children:"GetX"})," tambi\xe9n puedes olvidarte de este c\xf3digo de boilerplate ."]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"StreamBuilder( \u2026 )"})," ? ",(0,s.jsx)(a.code,{children:"initialValue: \u2026"})," ? ",(0,s.jsx)(a.code,{children:"builder: \u2026"})," ? No, s\xf3lo necesitas colocar esta variable dentro de un Widget ",(0,s.jsx)(a.code,{children:"Obx()"}),"."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"Obx (() => Text (controller.name));\n"})}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.em,{children:"\xbfQu\xe9 necesitas memorizar?"})," S\xf3lo ",(0,s.jsx)(a.code,{children:"Obx(() =>"})," ."]}),"\n",(0,s.jsxs)(a.p,{children:["Usted est\xe1 pasando ese Widget a trav\xe9s de una funci\xf3n de flecha en un ",(0,s.jsx)(a.code,{children:"Obx()"}),' (el "Observador" del ',(0,s.jsx)(a.em,{children:"Rx"}),")."]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"Obx"})," es bastante inteligente, y solo cambiar\xe1 si el valor de ",(0,s.jsx)(a.code,{children:"controller.name"})," cambia."]}),"\n",(0,s.jsxs)(a.p,{children:["Si ",(0,s.jsx)(a.code,{children:"name"})," es ",(0,s.jsx)(a.code,{children:'"John"'})," , y lo cambias a ",(0,s.jsx)(a.code,{children:'"John"'})," ( ",(0,s.jsx)(a.code,{children:'name. alue = "John"'})," ), como es el mismo ",(0,s.jsx)(a.code,{children:"valor"})," que antes, nada cambiar\xe1 en la pantalla, y ",(0,s.jsx)(a.code,{children:"Obx"})," , para ahorrar recursos, simplemente ignorar\xe1 el nuevo valor y no reconstruir\xe1 el Widget. ",(0,s.jsx)(a.strong,{children:"\xbfNo es asombroso?"})]}),"\n",(0,s.jsxs)(a.blockquote,{children:["\n",(0,s.jsxs)(a.p,{children:["Entonces, \xbfqu\xe9 pasa si tengo 5 variables ",(0,s.jsx)(a.em,{children:"Rx"})," (observables) dentro de un ",(0,s.jsx)(a.code,{children:"Obx"}),"?"]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["S\xf3lo se actualizar\xe1 cuando ",(0,s.jsx)(a.strong,{children:"cualquiera"})," de ellos cambie."]}),"\n",(0,s.jsxs)(a.blockquote,{children:["\n",(0,s.jsxs)(a.p,{children:["Y si tengo 30 variables en una clase, cuando actualic\xe9 una, \xbfactualizar\xe1 ",(0,s.jsx)(a.strong,{children:"todas"})," las variables que est\xe1n en esa clase?"]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["No, s\xf3lo el ",(0,s.jsx)(a.strong,{children:"Widget espec\xedfico"})," que usa esa variable ",(0,s.jsx)(a.em,{children:"Rx"}),"."]}),"\n",(0,s.jsxs)(a.p,{children:["Por lo tanto, ",(0,s.jsx)(a.strong,{children:"GetX"})," s\xf3lo actualiza la pantalla, cuando la variable ",(0,s.jsx)(a.em,{children:"Rx"})," cambia su valor."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{children:"\nfinal isOpen = false.obs;\n\n// NOTHING will happen... same value.\nvoid onButtonTap() => isOpen.value=false;\n"})}),"\n",(0,s.jsx)(a.h3,{id:"ventajas",children:"Ventajas"}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"GetX()"})," te ayuda cuando necesitas un control ",(0,s.jsx)(a.strong,{children:"granular"})," sobre lo que se est\xe1 actualizando."]}),"\n",(0,s.jsxs)(a.p,{children:["Si no necesitas ",(0,s.jsx)(a.code,{children:"identificadores \xfanicos"})," , porque todas tus variables ser\xe1n modificadas cuando realices una acci\xf3n, entonces usa ",(0,s.jsx)(a.code,{children:"GetBuilder"})," ,\nporque es un Actualizador de Estado Simple (en bloques, como ",(0,s.jsx)(a.code,{children:"setState()"})," ), hecho en unas pocas l\xedneas de c\xf3digo.\nSe hizo simple, para tener el menor impacto de la CPU, y s\xf3lo para cumplir un \xfanico prop\xf3sito (una reconstrucci\xf3n de ",(0,s.jsx)(a.em,{children:"Estado"}),") y gastar los recursos m\xednimos posibles."]}),"\n",(0,s.jsxs)(a.p,{children:["Si necesitas un administrador de estado ",(0,s.jsx)(a.strong,{children:"poderoso"}),", no puedes ir mal con ",(0,s.jsx)(a.strong,{children:"GetX"}),"."]}),"\n",(0,s.jsxs)(a.p,{children:["No funciona con variables, pero ",(0,s.jsx)(a.strong,{children:"flows"}),", todo en \xe9l es ",(0,s.jsx)(a.code,{children:"Streams"})," bajo el cap\xf3."]}),"\n",(0,s.jsxs)(a.p,{children:["Puedes usar ",(0,s.jsx)(a.em,{children:"rxDart"})," junto con \xe9l, porque todo es ",(0,s.jsx)(a.code,{children:"Streams"}),",\npuedes escuchar el ",(0,s.jsx)(a.code,{children:"evento"}),' de cada variable "',(0,s.jsx)(a.em,{children:"Rx"}),'",\nporque todo en \xe9l son ',(0,s.jsx)(a.code,{children:"Streams"}),"."]}),"\n",(0,s.jsxs)(a.p,{children:["Es literalmente un enfoque ",(0,s.jsx)(a.em,{children:"BLoC"})," m\xe1s f\xe1cil que ",(0,s.jsx)(a.em,{children:"MobX"}),", y sin generadores de c\xf3digo ni decoraciones.\nPuedes convertir ",(0,s.jsx)(a.strong,{children:"cualquier cosa"})," en un ",(0,s.jsx)(a.em,{children:'"Observable"'})," con s\xf3lo un ",(0,s.jsx)(a.code,{children:".obs"})," ."]}),"\n",(0,s.jsx)(a.h3,{id:"m\xe1ximo-rendimiento",children:"M\xe1ximo rendimiento:"}),"\n",(0,s.jsxs)(a.p,{children:["Adem\xe1s de tener un algoritmo inteligente para recompilaciones m\xednimas, ",(0,s.jsx)(a.strong,{children:"GetX"})," utiliza comparadores\npara asegurarse de que el Estado ha cambiado."]}),"\n",(0,s.jsxs)(a.p,{children:["If you experience any errors in your app, and send a duplicate change of State,\n",(0,s.jsx)(a.strong,{children:"GetX"})," will ensure it will not crash."]}),"\n",(0,s.jsxs)(a.p,{children:["Con ",(0,s.jsx)(a.strong,{children:"GetX"})," el estado s\xf3lo cambia si el ",(0,s.jsx)(a.code,{children:"valor"})," cambia.\nEsa es la diferencia principal entre ",(0,s.jsx)(a.strong,{children:"GetX"}),", y usando _ ",(0,s.jsx)(a.code,{children:"computed"})," de MobX_.\nAl unirse a dos ",(0,s.jsx)(a.strong,{children:"observables"}),", y uno cambia; el oyente de ese ",(0,s.jsx)(a.em,{children:"observable"})," tambi\xe9n cambiar\xe1."]}),"\n",(0,s.jsxs)(a.p,{children:["Con ",(0,s.jsx)(a.strong,{children:"GetX"}),", si te unes a dos variables, ",(0,s.jsx)(a.code,{children:"GetX()"})," (similar a ",(0,s.jsx)(a.code,{children:"Observer()"})," ) s\xf3lo se reconstruir\xe1 si implica un cambio real de Estado."]}),"\n",(0,s.jsx)(a.h3,{id:"declarando-una-variable-reactiva",children:"Declarando una variable reactiva"}),"\n",(0,s.jsx)(a.p,{children:'Tienes 3 maneras de convertir una variable en un "observable".'}),"\n",(0,s.jsxs)(a.p,{children:["1 - El primero est\xe1 usando ",(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"Rx{Type}"})}),"."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// initial value is recommended, but not mandatory\nfinal name = RxString('');\nfinal isLogged = RxBool(false);\nfinal count = RxInt(0);\nfinal balance = RxDouble(0.0);\nfinal items = RxList<String>([]);\nfinal myMap = RxMap<String, int>({});\n"})}),"\n",(0,s.jsxs)(a.p,{children:["2 - El segundo es usar ",(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"Rx"})})," y usar Darts Gen\xe9ricos, ",(0,s.jsx)(a.code,{children:"Rx<Type>"})]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"final name = Rx<String>('');\nfinal isLogged = Rx<Bool>(false);\nfinal count = Rx<Int>(0);\nfinal balance = Rx<Double>(0.0);\nfinal number = Rx<Num>(0);\nfinal items = Rx<List<String>>([]);\nfinal myMap = Rx<Map<String, int>>({});\n\n// Custom classes - it can be any class, literally\nfinal user = Rx<User>();\n"})}),"\n",(0,s.jsxs)(a.p,{children:["3 - El tercero, m\xe1s pr\xe1ctico, m\xe1s f\xe1cil y preferido enfoque, s\xf3lo a\xf1ade ",(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:".obs"})})," como una propiedad de tu ",(0,s.jsx)(a.code,{children:"valor"}),":"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"final name = ''.obs;\nfinal isLogged = false.obs;\nfinal count = 0.obs;\nfinal balance = 0.0.obs;\nfinal number = 0.obs;\nfinal items = <String>[].obs;\nfinal myMap = <String, int>{}.obs;\n\n// Custom classes - it can be any class, literally\nfinal user = User().obs;\n"})}),"\n",(0,s.jsx)(a.h5,{id:"tener-un-estado-reactivo-es-f\xe1cil",children:"Tener un estado reactivo es f\xe1cil."}),"\n",(0,s.jsxs)(a.p,{children:["Como sabemos, ",(0,s.jsx)(a.em,{children:"Dart"})," ahora se dirige hacia ",(0,s.jsx)(a.em,{children:"null_nul"}),".\nPara estar preparado, a partir de ahora, siempre deber\xedas iniciar tus variables ",(0,s.jsx)(a.em,{children:"Rx"})," con un ",(0,s.jsx)(a.strong,{children:"valor inicial"}),"."]}),"\n",(0,s.jsxs)(a.blockquote,{children:["\n",(0,s.jsxs)(a.p,{children:["Transformar una variable en un ",(0,s.jsx)(a.em,{children:"observable"})," + ",(0,s.jsx)(a.em,{children:"valor inicial"})," con ",(0,s.jsx)(a.strong,{children:"GetX"})," es el enfoque m\xe1s simple y pr\xe1ctico."]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:['Literalmente a\xf1adir\xe1s un " ',(0,s.jsx)(a.code,{children:".obs"}),' " al final de tu variable, y ',(0,s.jsx)(a.strong,{children:"eso"}),", lo has hecho observable,\ny su ",(0,s.jsx)(a.code,{children:". alue"})," , bueno, ser\xe1 el ",(0,s.jsx)(a.em,{children:"valor inicial"}),")."]}),"\n",(0,s.jsx)(a.h3,{id:"usar-los-valores-en-la-vista",children:"Usar los valores en la vista"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// controller file\nfinal count1 = 0.obs;\nfinal count2 = 0.obs;\nint get sum => count1.value + count2.value;\n"})}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// view file\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 1 rebuild\");\n    return Text('${controller.count1.value}');\n  },\n),\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 2 rebuild\");\n    return Text('${controller.count2.value}');\n  },\n),\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 3 rebuild\");\n    return Text('${controller.sum}');\n  },\n),\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Si incrementamos ",(0,s.jsx)(a.code,{children:"count1.value++"})," , se imprimir\xe1:"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.code,{children:"cuenta 1 reconstrucci\xf3n"})}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.code,{children:"cuenta 3 de reconstrucci\xf3n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["porque ",(0,s.jsx)(a.code,{children:"count1"})," tiene un valor de ",(0,s.jsx)(a.code,{children:"1"})," y ",(0,s.jsx)(a.code,{children:"1 + 0 = 1"})," , cambiando el valor de ",(0,s.jsx)(a.code,{children:"suma"})," getter."]}),"\n",(0,s.jsxs)(a.p,{children:["Si cambiamos ",(0,s.jsx)(a.code,{children:"count2.value++"})," , se imprimir\xe1:"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.code,{children:"count 2 recompilaci\xf3n"})}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.code,{children:"cuenta 3 de reconstrucci\xf3n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["porque ",(0,s.jsx)(a.code,{children:"count2.value"})," cambi\xf3, y el resultado de la ",(0,s.jsx)(a.code,{children:"sum"})," es ahora ",(0,s.jsx)(a.code,{children:"2"})," ."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["NOTA: De forma predeterminada, el primer evento reconstruir\xe1 el widget, incluso si es el mismo ",(0,s.jsx)(a.code,{children:"value"}),"."]}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"Este comportamiento existe debido a variables booleanas."}),"\n",(0,s.jsx)(a.p,{children:"Imagina que hiciste esto:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"var isLogged = false.obs;\n"})}),"\n",(0,s.jsxs)(a.p,{children:['Y luego, comprobaste si un usuario est\xe1 "conectado" para activar un evento en ',(0,s.jsx)(a.code,{children:"ever"})," ."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"@override\nonInit() async {\n  ever(isLogged, fireRoute);\n  isLogged.value = await Preferences.hasToken();\n}\n\nfireRoute(logged) {\n  if (logged) {\n   Get.off(Home());\n  } else {\n   Get.off(Login());\n  }\n}\n"})}),"\n",(0,s.jsxs)(a.p,{children:["si ",(0,s.jsx)(a.code,{children:"hasToken"})," fuera ",(0,s.jsx)(a.code,{children:"false"})," , no habr\xeda ning\xfan cambio en ",(0,s.jsx)(a.code,{children:"isLogged"})," , as\xed que ",(0,s.jsx)(a.code,{children:"ever()"})," nunca ser\xeda llamado.\nPara evitar este tipo de comportamiento, el primer cambio a un ",(0,s.jsx)(a.em,{children:"observable"})," siempre activar\xe1 un evento,\nincluso si contiene el mismo ",(0,s.jsx)(a.code,{children:". alue"})," ."]}),"\n",(0,s.jsxs)(a.p,{children:["Puede eliminar este comportamiento si lo desea, usando:\n",(0,s.jsx)(a.code,{children:"isLogged.firstRebuild = false;"})]}),"\n",(0,s.jsx)(a.h3,{id:"condiciones-para-reconstruir",children:"Condiciones para reconstruir"}),"\n",(0,s.jsx)(a.p,{children:"Adem\xe1s, Get proporciona un control refinado del estado. Puede condicionar un evento (como agregar un objeto a una lista), en una determinada condici\xf3n."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// First parameter: condition, must return true or false.\n// Second parameter: the new value to apply if the condition is true.\nlist.addIf(item < limit, item);\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Sin decoraciones, sin un generador de c\xf3digo, sin complicaciones ","\ud83d\ude04"]}),"\n",(0,s.jsx)(a.p,{children:"\xbfConoces la aplicaci\xf3n contador de Flutter? Tu clase Controller podr\xeda verse as\xed:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class CountController extends GetxController {\n  final count = 0.obs;\n}\n"})}),"\n",(0,s.jsx)(a.p,{children:"Con un simple:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"controller.count.value++\n"})}),"\n",(0,s.jsx)(a.p,{children:"Puede actualizar la variable contador en su interfaz de usuario, independientemente de d\xf3nde se almacena."}),"\n",(0,s.jsx)(a.h3,{id:"donde-obs-pueden-ser-usados",children:"Donde .obs pueden ser usados"}),"\n",(0,s.jsx)(a.p,{children:"Puedes transformar cualquier cosa en obs. Aqu\xed hay dos maneras de hacerlo:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Puedes convertir los valores de tu clase a obs"}),"\n"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:'class RxUser {\n  final name = "Camila".obs;\n  final age = 18.obs;\n}\n'})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"o puede convertir toda la clase para ser observable"}),"\n"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:'class User {\n  User({String name, int age});\n  var name;\n  var age;\n}\n\n// when instantianting:\nfinal user = User(name: "Camila", age: 18).obs;\n'})}),"\n",(0,s.jsx)(a.h3,{id:"nota-sobre-listas",children:"Nota sobre listas"}),"\n",(0,s.jsx)(a.p,{children:"Las listas son completamente observables al igual que los objetos dentro de ellas. De esta manera, si a\xf1ade un valor a una lista, autom\xe1ticamente reconstruir\xe1 los widgets que la utilizan."}),"\n",(0,s.jsx)(a.p,{children:'Tambi\xe9n no necesitas usar ".value" con listas, la incre\xedble api dart nos permiti\xf3 eliminar eso.\nLamentablemente no se pueden extender tipos primitivos como String y int, haciendo uso de . alue obligory, pero eso no ser\xe1 un problema si trabajas con consigue y setters para estos.'}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// On the controller\nfinal String title = 'User Info:'.obs\nfinal list = List<User>().obs;\n\n// on the view\nText(controller.title.value), // String need to have .value in front of it\nListView.builder (\n  itemCount: controller.list.length // lists don't need it\n)\n"})}),"\n",(0,s.jsx)(a.p,{children:"Cuando est\xe1s haciendo que tus propias clases sean observables, hay una forma diferente de actualizarlas:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// on the model file\n// we are going to make the entire class observable instead of each attribute\nclass User() {\n  User({this.name = '', this.age = 0});\n  String name;\n  int age;\n}\n\n// on the controller file\nfinal user = User().obs;\n// when you need to update the user variable:\nuser.update( (user) { // this parameter is the class itself that you want to update\nuser.name = 'Jonny';\nuser.age = 18;\n});\n// an alternative way of update the user variable:\nuser(User(name: 'Jo\xe3o', age: 35));\n\n// on view:\nObx(()=> Text(\"Name ${user.value.name}: Age: ${user.value.age}\"))\n// you can also access the model values without the .value:\nuser().name; // notice that is the user variable, not the class (variable has lowercase u)\n"})}),"\n",(0,s.jsx)(a.p,{children:'No tienes que trabajar con conjuntos si no lo deseas. Puedes usar el "assign \'and" asignado "api".\nLa api "asignar" borrar\xe1 su lista y a\xf1adir\xe1 un solo objeto que desea comenzar all\xed.\nLa api "assignAll" borrar\xe1 la lista existente y a\xf1adir\xe1 cualquier objeto iterable que se inyecte en ella.'}),"\n",(0,s.jsx)(a.h3,{id:"por-qu\xe9-tengo-que-usar-value",children:"\xbfPor qu\xe9 tengo que usar .value"}),"\n",(0,s.jsx)(a.p,{children:"Podr\xedamos eliminar la obligaci\xf3n de usar 'valor' en 'cadena' e 'int' con un generador de c\xf3digo y decoraci\xf3n simple, pero el prop\xf3sito de esta biblioteca es precisamente evitar dependencias externas. Queremos ofrecer un entorno listo para la programaci\xf3n, que implique lo esencial (gesti\xf3n de rutas, dependencias y estados), de una manera sencilla, ligera y eficiente, sin necesidad de un paquete externo."}),"\n",(0,s.jsx)(a.p,{children:"Literalmente puedes a\xf1adir 3 letras a tu pubspec (get) y dos puntos y empezar a programar. Todas las soluciones incluidas por defecto, desde la gesti\xf3n de rutas hasta la gesti\xf3n estatal, apuntan a la facilidad, productividad y rendimiento."}),"\n",(0,s.jsx)(a.p,{children:"El peso total de esta biblioteca es menor que el de un \xfanico administrador estatal, aunque sea una soluci\xf3n completa, y eso es lo que ustedes deben entender."}),"\n",(0,s.jsxs)(a.p,{children:["Si usted est\xe1 molesto por ",(0,s.jsx)(a.code,{children:". alue"}),' , y como un generador de c\xf3digo, MobX es una gran alternativa, y puede usarlo junto con Get. Para aquellos que quieran a\xf1adir una sola dependencia en pubspec y empezar a programar sin preocuparse por que la versi\xf3n de un paquete sea incompatible con otra, o si el error de una actualizaci\xf3n de estado proviene del administrador de estado o dependencia, o a\xfan as\xed, no quieren preocuparse por la disponibilidad de controladores, si literalmente "s\xf3lo programaci\xf3n", obtener es perfecto.']}),"\n",(0,s.jsx)(a.p,{children:"Si no tiene ning\xfan problema con el generador de c\xf3digo MobX, o no tiene ning\xfan problema con el boilerplate BLoC, usted puede simplemente usar Get para rutas, y olvidar que tiene el administrador del estado. Obtener SEM y RSM nacieron de la necesidad, mi empresa ten\xeda un proyecto con m\xe1s de 90 controladores, y el generador de c\xf3digo simplemente tard\xf3 m\xe1s de 30 minutos en completar sus tareas despu\xe9s de una limpieza de flujido en una m\xe1quina razonablemente buena, si su proyecto tiene 5, 10, 15 controladores, cualquier administrador estatal le suministrar\xe1 bien. Si tiene un proyecto absurdamente grande, y el generador de c\xf3digo es un problema para usted, se le ha concedido esta soluci\xf3n."}),"\n",(0,s.jsx)(a.p,{children:"Obviamente, si alguien quiere contribuir al proyecto y crear un generador de c\xf3digo, o algo similar, enlazar\xe9 en este l\xe9ame como una alternativa, Mi necesidad no es la necesidad de todos los desarrolladores, pero por ahora digo, hay buenas soluciones que ya hacen eso, como MobX."}),"\n",(0,s.jsx)(a.h3,{id:"obx",children:"Obx()"}),"\n",(0,s.jsxs)(a.p,{children:["Escribir en Get using Bindings es innecesario. puede utilizar el widget Obx en lugar de GetX que s\xf3lo recibe la funci\xf3n an\xf3nima que crea un widget.\nObviamente, si no usas un tipo, necesitar\xe1s tener una instancia de tu controlador para usar las variables, o usar ",(0,s.jsx)(a.code,{children:"Get. enlazar<Controller>()"})," .value o Controller.to.value para recuperar el valor."]}),"\n",(0,s.jsx)(a.h3,{id:"trabajadores",children:"Trabajadores"}),"\n",(0,s.jsx)(a.p,{children:"Los trabajadores le ayudar\xe1n, activando llamadas espec\xedficas cuando ocurra un evento."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:'/// Called every time `count1` changes.\never(count1, (_) => print("$_ has been changed"));\n\n/// Called only first time the variable $_ is changed\nonce(count1, (_) => print("$_ was changed once"));\n\n/// Anti DDos - Called every time the user stops typing for 1 second, for example.\ndebounce(count1, (_) => print("debouce$_"), time: Duration(seconds: 1));\n\n/// Ignore all changes within 1 second.\ninterval(count1, (_) => print("interval $_"), time: Duration(seconds: 1));\n'})}),"\n",(0,s.jsxs)(a.p,{children:["Todos los trabajadores (excepto ",(0,s.jsx)(a.code,{children:"debounce"})," ) tienen un par\xe1metro llamado ",(0,s.jsx)(a.code,{children:"condition"}),", que puede ser un ",(0,s.jsx)(a.code,{children:"bool"})," o un callback que devuelva un ",(0,s.jsx)(a.code,{children:"bool"})," .\nEsta ",(0,s.jsx)(a.code,{children:"condici\xf3n"})," define cuando la funci\xf3n ",(0,s.jsx)(a.code,{children:"callback"})," se ejecuta."]}),"\n",(0,s.jsxs)(a.p,{children:["Todos los trabajadores devuelven una instancia de ",(0,s.jsx)(a.code,{children:"Worker"}),", que puedes usar para cancelar ( a trav\xe9s de ",(0,s.jsx)(a.code,{children:"dispose()"})," ) el worker."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"nunca"})})}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["se llama cada vez que la variable ",(0,s.jsx)(a.em,{children:"Rx"})," emite un nuevo valor."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"todo"})})}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["Al igual que ",(0,s.jsx)(a.code,{children:"ever"})," , pero toma una ",(0,s.jsx)(a.code,{children:"List"})," de valores ",(0,s.jsx)(a.em,{children:"Rx"})," llamada cada vez que su variable es cambiada. Eso es todo."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"una vez"})})}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"'una vez' se llama s\xf3lo la primera vez que la variable ha sido cambiada."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"debounce"})})}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:'\'debounce\' es muy \xfatil en las funciones de b\xfasqueda, donde s\xf3lo quieres que se llame a la API cuando el usuario termine de teclear. Si el usuario escribe "Jonny", tendr\xe1 5 b\xfasquedas en las APIs, por la letra J, n, n y y. Con Get esto no sucede, porque usted tendr\xe1 un Trabajador de "deshacer" que s\xf3lo se activar\xe1 al final de la escritura.'}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.strong,{children:(0,s.jsx)(a.code,{children:"intervalo"})})}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"'intervalo' es diferente del escombro. debouce si el usuario hace 1000 cambios a una variable dentro de 1 segundo, enviar\xe1 s\xf3lo el \xfaltimo despu\xe9s del temporizador sofocado (el valor por defecto es 800 milisegundos). Intervalo en su lugar ignorar\xe1 todas las acciones del usuario durante el per\xedodo asfixiado. Si env\xedas eventos por 1 minuto, 1000 por segundo, descomprimir s\xf3lo te enviar\xe1 el \xfaltimo, cuando el usuario deje de abrir eventos. el intervalo entregar\xe1 eventos cada segundo, y si se establece en 3 segundos, producir\xe1 20 eventos ese minuto. Esto se recomienda para evitar abusos, en funciones donde el usuario puede hacer clic r\xe1pidamente en algo y obtener alguna ventaja (imagina que el usuario puede ganar monedas haciendo clic en algo, si hizo clic 300 veces en el mismo minuto, tendr\xeda 300 monedas, usando intervalo, puedes establecer un marco de tiempo durante 3 segundos, e incluso luego hacer clic en 300 o mil veces, el m\xe1ximo que obtendr\xeda en 1 minuto ser\xedan 20 monedas, haciendo clic en 300 o 1 mill\xf3n de veces). La desconexi\xf3n es adecuada para anti-DDos, para funciones como buscar donde cada cambio a onChange causar\xeda una consulta a tu api. Debounce esperar\xe1 a que el usuario deje de escribir el nombre, para hacer la solicitud. Si se utilizara en el escenario de monedas mencionado anteriormente, el usuario s\xf3lo ganar\xeda 1 moneda, porque s\xf3lo se ejecuta cuando el usuario \"pausa\" para el tiempo establecido."}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"NOTA: Los trabajadores deben ser usados siempre al iniciar un controlador o clase, por lo que siempre debe estar en onInit (recomendado), constructor de clase, o el estado inicial de un StatefulWidget (esta pr\xe1ctica no se recomienda en la mayor\xeda de los casos, pero no deber\xeda tener efectos secundarios)."}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"gestor-de-estado-simple",children:"Gestor de Estado simple"}),"\n",(0,s.jsx)(a.p,{children:"Obtener tiene un administrador de estado que es extremadamente ligero y f\xe1cil, que no utiliza ChangeNotifier, satisfar\xe1 especialmente las necesidades de los nuevos a Flutter, y no causar\xe1 problemas para grandes aplicaciones."}),"\n",(0,s.jsx)(a.p,{children:'GetBuilder est\xe1 dirigido precisamente al control de m\xfaltiples estados. Imag\xednese que ha a\xf1adido 30 productos a un carrito, haga clic en eliminar uno, al mismo tiempo que la lista se actualiza, el precio se actualiza y la insignia en el carrito de la compra se actualiza a un n\xfamero m\xe1s peque\xf1o. Este tipo de enfoque hace que GetBuilder mate, porque agrupa a todos y los cambia a la vez sin ninguna "l\xf3gica computacional" para eso. GetBuilder fue creado con este tipo de situaci\xf3n en mente, desde el cambio efemeral de estado, puede usar setState y no necesitar\xe1 un gestor de estado para esto.'}),"\n",(0,s.jsx)(a.p,{children:'De esta manera, si quieres un controlador individual, puedes asignar IDs para eso, o usar GetX. Esto depende de ti, recordando que cuanto m\xe1s widgets "individual" tengas, m\xe1s destacar\xe1 el rendimiento de GetX mientras que el rendimiento de GetBuilder debe ser superior, cuando hay un cambio de estado m\xfaltiple.'}),"\n",(0,s.jsx)(a.h3,{id:"ventajas-1",children:"Ventajas"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Actualizar s\xf3lo los widgets necesarios."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"No utiliza changeNotifier, es el gestor de estado el que usa menos memoria (cerca de 0mb)."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"\xa1Olvidar StatefulWidget! Con Get nunca lo necesitar\xe1. Con los otros administradores de estado, probablemente tendr\xe1s que usar StatefulWidget para obtener la instancia de tu Provider, BLoC, Controlador MobX, etc. Pero, \xbfalguna vez has parado a pensar que tu appBar, tu andamio y la mayor\xeda de los widgets que est\xe1n en tu clase son sin estado? Entonces, \xbfpor qu\xe9 salvar el estado de toda una clase, si s\xf3lo puedes salvar el estado del Widget que es estatuario? Consigue que esto tambi\xe9n se resuelva. Crea una clase sin Estado, haz que todo est\xe9 sin estado. Si necesita actualizar un solo componente, envolverlo con GetBuilder, y su estado se mantendr\xe1."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Organiza tu proyecto de forma real! Los controladores no deben estar en tu interfaz de usuario, colocar tu TextEditController, o cualquier controlador que utilices dentro de tu clase Controller."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:'\xbfNecesitas activar un evento para actualizar un widget tan pronto como se procese? GetBuilder tiene la propiedad "initState", al igual que StatefulWidget, y puedes llamar a eventos desde tu controlador, directamente desde \xe9l, ya no m\xe1s eventos colocados en tu estado inicial.'}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"\xbfNecesitas desencadenar una acci\xf3n como cerrar secuencias, temporizadores y etc? GetBuilder tambi\xe9n tiene la propiedad de disponer, donde puede llamar a eventos tan pronto como ese widget sea destruido."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Usar streams s\xf3lo si es necesario. Puede utilizar sus Controladores StreamControllers dentro de su controlador normalmente, y usar StreamBuilder tambi\xe9n normalmente, pero recuerde, un flujo consume razonablemente memoria, la programaci\xf3n reactiva es hermosa, pero no deber\xeda abusar de ella. 30 streams abiertos simult\xe1neamente pueden ser peores que changeNotifier (y changeNotifier es muy mal)."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Actualizar widgets sin gastar rama para eso. Obt\xe9n tiendas s\xf3lo el ID del creador GetBuilder, y actualiza ese GetBuilder cuando sea necesario. El consumo de memoria del almacenamiento con ID en memoria es muy bajo, incluso para miles de GetBuilders. Cuando creas un nuevo GetBuilder, realmente est\xe1s compartiendo el estado de GetBuilder que tiene un ID de creador. Un nuevo estado no se crea para cada GetBuilder, que guarda un LOT OF ram para aplicaciones grandes. B\xe1sicamente su solicitud ser\xe1 completamente sin estado y los pocos Widgets que ser\xe1n Stateful (dentro de GetBuilder) tendr\xe1n un solo estado, y por lo tanto actualizar uno los actualizar\xe1 todos. El Estado es s\xf3lo uno."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Get es omnisciente y en la mayor\xeda de los casos sabe exactamente el tiempo para sacar a un controlador de la memoria. No deber\xedas preocuparte por cu\xe1ndo desmontar un controlador, Obtener sabe el mejor momento para hacer esto."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"uso",children:"Uso"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"// Create controller class and extends GetxController\nclass Controller extends GetxController {\n  int counter = 0;\n  void increment() {\n    counter++;\n    update(); // use update() to update counter variable on UI when increment be called\n  }\n}\n// On your Stateless/Stateful class, use GetBuilder to update Text when increment be called\nGetBuilder<Controller>(\n  init: Controller(), // INIT IT ONLY THE FIRST TIME\n  builder: (_) => Text(\n    '${_.counter}',\n  ),\n)\n//Initialize your controller only the first time. The second time you are using ReBuilder for the same controller, do not use it again. Your controller will be automatically removed from memory as soon as the widget that marked it as 'init' is deployed. You don't have to worry about that, Get will do it automatically, just make sure you don't start the same controller twice.\n"})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"Hecho!"})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Ya has aprendido a manejar estados con Get."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"Nota: Es posible que desee una organizaci\xf3n m\xe1s grande, y no utilizar la propiedad init. Para eso, puedes crear una clase y extender la clase Binding y dentro de ella mencionar los controladores que se crear\xe1n dentro de esa ruta. No se crear\xe1n controladores en ese momento, al contrario, se trata simplemente de una declaraci\xf3n. para que la primera vez que utilices un Controller, Obtener sabr\xe1 d\xf3nde mirar. Get will remain perazyLoad, and will continue to dispose Controllers when they are not needed. Vea el ejemplo pub.dev para ver c\xf3mo funciona."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"Si navega muchas rutas y necesita datos que estaban en su controlador previamente usado, s\xf3lo necesita usar GetBuilder otra vez (sin inicio):"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class OtherClass extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GetBuilder<Controller>(\n          builder: (s) => Text('${s.counter}'),\n        ),\n      ),\n    );\n  }\n\n"})}),"\n",(0,s.jsxs)(a.p,{children:["Si necesitas usar tu controlador en muchos otros lugares, y fuera de GetBuilder, s\xf3lo tienes que crear un get en tu controlador y tenerlo f\xe1cilmente. (o usa ",(0,s.jsx)(a.code,{children:"Get.find<Controller>()"})," )"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class Controller extends GetxController {\n\n  /// You do not need that. I recommend using it just for ease of syntax.\n  /// with static method: Controller.to.increment();\n  /// with no static method: Get.find<Controller>().increment();\n  /// There is no difference in performance, nor any side effect of using either syntax. Only one does not need the type, and the other the IDE will autocomplete it.\n  static Controller get to => Get.find(); // add this line\n\n  int counter = 0;\n  void increment() {\n    counter++;\n    update();\n  }\n}\n"})}),"\n",(0,s.jsx)(a.p,{children:"Y entonces puedes acceder directamente a tu controlador, de esa manera:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:'FloatingActionButton(\n  onPressed: () {\n    Controller.to.increment(),\n  } // This is incredibly simple!\n  child: Text("${Controller.to.counter}"),\n),\n'})}),"\n",(0,s.jsx)(a.p,{children:"Al pulsar FloatingActionButton, todos los widgets que est\xe9n escuchando la variable 'contador' se actualizar\xe1n autom\xe1ticamente."}),"\n",(0,s.jsx)(a.h3,{id:"c\xf3mo-maneja-los-controladores",children:"C\xf3mo maneja los controladores"}),"\n",(0,s.jsx)(a.p,{children:"Digamos lo siguiente:"}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.code,{children:"Clase a => Clase B (tiene controlador X) => Clase C (tiene controlador X)"})}),"\n",(0,s.jsx)(a.p,{children:'En la clase A, el controlador no est\xe1 todav\xeda en la memoria, porque a\xfan no la ha utilizado (Get is lazyLoad). En la clase B us\xf3 el controlador, y entr\xf3 en la memoria. En la clase C utilizaste el mismo controlador que en la clase B, Obtener compartir\xe1 el estado del controlador B con el controlador C, y el mismo controlador todav\xeda est\xe1 en memoria. Si cierra la pantalla C y la pantalla B, Get sacar\xe1 autom\xe1ticamente el controlador X de la memoria y liberar\xe1 recursos porque la clase a no est\xe1 usando el controlador. Si navega a B de nuevo, el controlador X volver\xe1 a entrar en la memoria, si en lugar de ir a la clase C, volviendo a la clase A otra vez, Get sacar\xe1 el controlador de la memoria de la misma manera. Si la clase C no us\xf3 el controlador, y sacaste la clase B de la memoria, ninguna clase usar\xeda el controlador X y tampoco estar\xeda dispuesta. La \xfanica excepci\xf3n que puede molestar con Get, es si elimina B de la ruta inesperadamente, e intenta usar el controlador en C. En este caso, el ID del creador del controlador que estaba en B fue eliminado, y Get fue programado para eliminarlo de la memoria de cada controlador que no tiene ID de creador. Si usted tiene la intenci\xf3n de hacer esto, agregue la bandera "autoRemove: false" a la clase B GetBuilder y use adoptID = true; en la clase C GetBuilder.'}),"\n",(0,s.jsx)(a.h3,{id:"ya-no-necesitar\xe1s-statefulwidgets",children:"Ya no necesitar\xe1s StatefulWidgets"}),"\n",(0,s.jsx)(a.p,{children:"Usar StatefulWidgets significa almacenar el estado de pantallas enteras innecesariamente, incluso porque necesita reconstruir m\xednimamente un widget, lo insertar\xe1s en un Consumer/Observer/BlocProvider/GetBuilder/GetX/Obx, el cual ser\xe1 otro StatefulWidget.\nLa clase StatefulWidget es una clase mayor que StatelessWidget, que asignar\xe1 m\xe1s RAM, y esto puede no marcar una diferencia significativa entre una o dos clases, pero sin duda lo har\xe1 cuando tenga 100 de ellas!\nA menos que necesite usar una mixin, como TickerProviderStateMixin, ser\xe1 totalmente innecesario usar un StatefulWidget con Get."}),"\n",(0,s.jsx)(a.p,{children:"Puedes llamar a todos los m\xe9todos de un StatefulWidget directamente desde un GetBuilder.\nSi necesita llamar al m\xe9todo initState() o dispose() por ejemplo, puede llamarlos directamente;"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  initState: (_) => Controller.to.fetchApi(),\n  dispose: (_) => Controller.to.closeStreams(),\n  builder: (s) => Text('${s.username}'),\n),\n"})}),"\n",(0,s.jsx)(a.p,{children:"Un enfoque mucho mejor que esto es usar el m\xe9todo onInit() y onClose() directamente desde el controlador."}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"@override\nvoid onInit() {\n  fetchApi();\n  super.onInit();\n}\n"})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"NOTA: Si quieres iniciar un m\xe9todo por el momento el controlador es llamado por primera vez, NO ES NECESARIO usar constructores para esto, de hecho, usando un paquete orientado al rendimiento como Get, esto limita con la mala pr\xe1ctica. porque se desvia de la l\xf3gica en la que se crean o asignan los controladores (si se crea una instancia de este controlador, el constructor ser\xe1 llamado inmediatamente, estar\xe1s poblando un controlador antes de que se utilice, est\xe1 asignando memoria sin que est\xe9 en uso, esto definitivamente perjudica los principios de esta biblioteca). Los m\xe9todos onInit(); y onClose(); fueron creados para esto, ser\xe1n llamados cuando el controlador sea creado, o usado por primera vez, dependiendo de si usted est\xe1 usando Get. azyPut o no. Si quieres, por ejemplo, hacer una llamada a tu API para rellenar datos, puedes olvidarte del m\xe9todo anticuado de initState/dispose, simplemente inicia tu llamada a la api en onInit, y si necesitas ejecutar cualquier comando como cerrar streams, usa onClose() para eso."}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"por-qu\xe9-existe",children:"Por qu\xe9 existe"}),"\n",(0,s.jsx)(a.p,{children:"El prop\xf3sito de este paquete es precisamente ofrecerle una soluci\xf3n completa para la navegaci\xf3n de rutas, gesti\xf3n de dependencias y estados, utilizando las menos dependencias posibles, con un alto grado de desacoplamiento. Consiga involucrarse con todas las APIs de nivel alto y bajo dentro de s\xed mismo, para asegurarse de que trabaja con el menor acoplamiento posible. Centralizamos todo en un solo paquete, para asegurar que no tenga ning\xfan tipo de acoplamiento en su proyecto. De esa manera, solo puedes poner widgets en tu vista, y dejar libre la parte de tu equipo que trabaja con la l\xf3gica de negocio. trabajar con la l\xf3gica de negocio sin depender de ning\xfan elemento de la Vista. Esto proporciona un entorno de trabajo mucho m\xe1s limpio, de modo que parte de tu equipo s\xf3lo funciona con widgets, sin preocuparse por enviar datos a tu controlador, y parte de su equipo trabaja s\xf3lo con la l\xf3gica de negocio en su pan, sin depender de ning\xfan elemento de la vista."}),"\n",(0,s.jsx)(a.p,{children:"As\xed que para simplificar esto:\nNo necesitas llamar a m\xe9todos en initState y enviarlos por par\xe1metro a tu controlador, ni utilice el constructor de su controlador para eso, tiene el m\xe9todo onInit() que se llama en el momento adecuado para iniciar sus servicios.\nNo necesita llamar al dispositivo, tiene el m\xe9todo onClose() que ser\xe1 llamado en el momento exacto en que su controlador ya no es necesario y ser\xe1 eliminado de la memoria. De esa manera, deje las vistas para los widgets solamente, acepte cualquier tipo de l\xf3gica de negocio de ella."}),"\n",(0,s.jsx)(a.p,{children:'No llamar a un m\xe9todo de dispose dentro de GetxController, no har\xe1 nada, recuerda que el controlador no es un Widget, no deber\xeda "eliminarlo", y ser\xe1 eliminada de forma autom\xe1tica e inteligente de la memoria por Get. Si ha utilizado alguna secuencia en ella y quiere cerrarla, simplemente insertarla en el m\xe9todo de cierre. Ejemplo:'}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class Controller extends GetxController {\n  StreamController<User> user = StreamController<User>();\n  StreamController<String> name = StreamController<String>();\n\n  /// close stream = onClose method, not dispose.\n  @override\n  void onClose() {\n    user.close();\n    name.close();\n    super.onClose();\n  }\n}\n"})}),"\n",(0,s.jsx)(a.p,{children:"Ciclo de vida del controlador:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"onInit() donde se crea."}),"\n",(0,s.jsx)(a.li,{children:"onClose() donde est\xe1 cerrado para realizar cualquier cambio en la preparaci\xf3n del m\xe9todo de eliminaci\xf3n"}),"\n",(0,s.jsx)(a.li,{children:"eliminado: no tiene acceso a esta API porque est\xe1 literalmente eliminando el controlador de la memoria. Es literalmente eliminado, sin dejar rastro."}),"\n"]}),"\n",(0,s.jsx)(a.h3,{id:"otras-formas-de-usarlo",children:"Otras formas de usarlo"}),"\n",(0,s.jsx)(a.p,{children:"Puede utilizar la instancia del controlador directamente en el valor de GetBuilder:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  init: Controller(),\n  builder: (value) => Text(\n    '${value.counter}', //here\n  ),\n),\n"})}),"\n",(0,s.jsx)(a.p,{children:"Tambi\xe9n puede que necesites una instancia de tu controlador fuera de tu GetBuilder, y puedes usar estos m\xe9todos para lograr esto:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class Controller extends GetxController {\n  static Controller get to => Get.find();\n[...]\n}\n// on you view:\nGetBuilder<Controller>(  \n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Controller.to.counter}', //here\n  )\n),\n"})}),"\n",(0,s.jsx)(a.p,{children:"o"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class Controller extends GetxController {\n // static Controller get to => Get.find(); // with no static get\n[...]\n}\n// on stateful/stateless class\nGetBuilder<Controller>(  \n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Get.find<Controller>().counter}', //here\n  ),\n),\n"})}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:'Puedes usar enfoques "no can\xf3nicos" para hacer esto. Si est\xe1s usando alg\xfan otro gestor de dependencias, como get_it, modular, etc., y solo quieres entregar la instancia del controlador, puedes hacer esto:'}),"\n"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"Controller controller = Controller();\n[...]\nGetBuilder<Controller>(\n  init: controller, //here\n  builder: (_) => Text(\n    '${controller.counter}', // here\n  ),\n),\n\n"})}),"\n",(0,s.jsx)(a.h3,{id:"ids-\xfanicos",children:"IDs \xfanicos"}),"\n",(0,s.jsx)(a.p,{children:"Si desea refinar el control de actualizaciones de un widget con GetBuilder, puede asignarles IDs \xfanicos:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  id: 'text'\n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Get.find<Controller>().counter}', //here\n  ),\n),\n"})}),"\n",(0,s.jsx)(a.p,{children:"Y actual\xedcela este formulario:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"update(['text']);\n"})}),"\n",(0,s.jsx)(a.p,{children:"Tambi\xe9n puede imponer condiciones para la actualizaci\xf3n:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"update(['text'], counter < 10);\n"})}),"\n",(0,s.jsx)(a.p,{children:"GetX hace esto autom\xe1ticamente y s\xf3lo reconstruye el widget que utiliza la variable exacta que fue cambiada, si cambia una variable a la misma que la anterior y eso no implica un cambio de estado , GetX no reconstruir\xe1 el widget para ahorrar memoria y ciclos de CPU (3 se muestra en la pantalla, y cambias la variable a 3 de nuevo. En la mayor\xeda de los administradores estatales, esto causar\xe1 una nueva reconstrucci\xf3n, pero con GetX el widget s\xf3lo se reconstruir\xe1 de nuevo, si de hecho su estado ha cambiado)."}),"\n",(0,s.jsx)(a.h2,{id:"mezclar-los-dos-administradores-estatales",children:"Mezclar los dos administradores estatales"}),"\n",(0,s.jsx)(a.p,{children:'Algunas personas abrieron una petici\xf3n de caracter\xedsticas, ya que quer\xedan usar solo un tipo de variable reactiva, y las otras mec\xe1nicas, y necesarias para insertar un Obx en un GetBuilder para esto. Pensando en ello se cre\xf3 MixinBuilder. Permite tanto cambios reactivos cambiando variables ".obs", como actualizaciones mec\xe1nicas a trav\xe9s de update(). Sin embargo, de los 4 widgets \xe9l es el que consume m\xe1s recursos, ya que adem\xe1s de tener una Suscripci\xf3n para recibir eventos de cambio de sus hijos, se suscribe al m\xe9todo de actualizaci\xf3n de su controlador.'}),"\n",(0,s.jsx)(a.p,{children:'Extender GetxController es importante, ya que tienen ciclos de vida, y pueden "iniciar" y "terminar" eventos en sus m\xe9todos onInit() y onClose(). Puede usar cualquier clase para esto, pero le recomiendo encarecidamente que utilice la clase GetxController para colocar sus variables, sean observables o no.'}),"\n",(0,s.jsx)(a.h2,{id:"mixin-de-estado",children:"Mixin de estado"}),"\n",(0,s.jsxs)(a.p,{children:["Otra forma de manejar tu estado ",(0,s.jsx)(a.code,{children:"UI"})," es usar el ",(0,s.jsx)(a.code,{children:"StateMixin<T>"})," .\nPara implementarlo, usa el ",(0,s.jsx)(a.code,{children:"con"})," para agregar el ",(0,s.jsx)(a.code,{children:"StateMixin<T>"}),"\na tu controlador que permite un modelo T."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class Controller extends GetController with StateMixin<User>{}\n"})}),"\n",(0,s.jsxs)(a.p,{children:["El m\xe9todo ",(0,s.jsx)(a.code,{children:"change()"})," cambia el Estado siempre que queremos.\nSimplemente pase los datos y el estado de esta manera:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"change(data, status: RxStatus.success());\n"})}),"\n",(0,s.jsx)(a.p,{children:"RxStatus permite estos estados:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"RxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n"})}),"\n",(0,s.jsx)(a.p,{children:"Para representarlo en la interfaz de usuario, use:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-dart",children:"class OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n"})}),"\n",(0,s.jsx)(a.h2,{id:"getbuilder-vs-getx-vs-obx-vs-mixinbuilder",children:"GetBuilder vs GetX vs Obx vs MixinBuilder"}),"\n",(0,s.jsx)(a.p,{children:"En una d\xe9cada trabajando con la programaci\xf3n pude aprender algunas lecciones valiosas."}),"\n",(0,s.jsx)(a.p,{children:'Mi primer contacto con la programaci\xf3n reactiva fue tan "wow, esto es incre\xedble" y de hecho la programaci\xf3n reactiva es incre\xedble.\nSin embargo, no es adecuado para todas las situaciones. A menudo todo lo que necesitas es cambiar el estado de 2 o 3 widgets al mismo tiempo, o un cambio efemeral de estado, en cuyo caso la programaci\xf3n reactiva no es mala, pero no es apropiada.'}),"\n",(0,s.jsx)(a.p,{children:"La programaci\xf3n reactiva tiene un mayor consumo de RAM que puede ser compensado por el flujo de trabajo individual, que asegurar\xe1 que s\xf3lo un widget sea reconstruido y cuando sea necesario, pero crear una lista con 80 objetos, cada uno con varios streams no es una buena idea. Abre el oscurecimiento y comprueba cu\xe1nto consume un StreamBuilder, y entender\xe1s lo que estoy tratando de decirte."}),"\n",(0,s.jsx)(a.p,{children:"Con eso en mente, cre\xe9 el simple gestor estatal. Es simple, y eso es exactamente lo que deber\xeda exigir de \xe9l: actualizar el estado en bloques de una manera sencilla, y de la manera m\xe1s econ\xf3mica."}),"\n",(0,s.jsx)(a.p,{children:"GetBuilder es muy econ\xf3mico en RAM, y apenas hay un enfoque m\xe1s econ\xf3mico que \xe9l (al menos no puedo imaginar uno, si existe, por favor h\xe1ganoslo saber)."}),"\n",(0,s.jsx)(a.p,{children:"Sin embargo, GetBuilder sigue siendo un gestor de estado mec\xe1nico, necesita llamar update() del mismo modo que necesita llamar notificar a Provider()."}),"\n",(0,s.jsx)(a.p,{children:"Hay otras situaciones en las que la programaci\xf3n reactiva es realmente interesante, y no trabajar con ella es lo mismo que reinventar la rueda. Con esto en mente, GetX fue creado para proporcionar todo lo que es m\xe1s moderno y avanzado en un administrador estatal. Actualiza s\xf3lo lo que es necesario y cuando es necesario, si tiene un error y env\xeda 300 cambios de estado simult\xe1neamente, GetX filtrar\xe1 y actualizar\xe1 la pantalla s\xf3lo si el estado realmente cambia."}),"\n",(0,s.jsx)(a.p,{children:"GetX es a\xfan m\xe1s econ\xf3mico que cualquier otro gestor de estado reactivo, pero consume un poco m\xe1s de RAM que GetBuilder. Pensando en ello y tratando de maximizar el consumo de recursos que Obx fue creado. A diferencia de GetX y GetBuilder, no podr\xe1s inicializar un controlador dentro de un Obx, es s\xf3lo un Widget con un StreamSubssubscription que recibe cambios de eventos de sus hijos, eso es todo. Es m\xe1s econ\xf3mico que GetX, pero pierde en GetBuilder, que era de esperar, ya que es reactivo, y GetBuilder tiene el enfoque m\xe1s simplista que existe, de almacenar el hashcode de un widget y su StateSetter. Con Obx no necesitas escribir tu tipo de controlador y puedes escuchar el cambio desde m\xfaltiples controladores diferentes, pero necesita inicializarse antes, ya sea usando el m\xe9todo de ejemplo al principio de este readme, o usando la clase Bindings."})]})}function u(e={}){const{wrapper:a}={...(0,o.a)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>l,a:()=>i});var s=n(7294);const o={},r=s.createContext(o);function i(e){const a=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:a},e.children)}}}]);