"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[480],{7163:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var s=n(5893),o=n(1151);const r={sidebar_position:2},t="Acerca de GetX",i={id:"about",title:"Acerca de GetX",description:"- GetX es una soluci\xf3n extra ligera y potente para Flutter. Combina gesti\xf3n estatal de alto rendimiento, inyecci\xf3n inteligente de dependencias y gesti\xf3n de rutas de manera r\xe1pida y pr\xe1ctica.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/about.md",sourceDirName:".",slug:"/about",permalink:"/getx/es/docs/about",draft:!1,unlisted:!1,editUrl:"https://github.com/jonataslaw/getx/docs/about.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Empezar",permalink:"/getx/es/docs/intro"},next:{title:"Concepts",permalink:"/getx/es/docs/category/concepts"}},l={},c=[{value:"\xbfPor qu\xe9 conseguir?",id:"por-qu\xe9-conseguir",level:2}];function d(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"acerca-de-getx",children:"Acerca de GetX"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"GetX es una soluci\xf3n extra ligera y potente para Flutter. Combina gesti\xf3n estatal de alto rendimiento, inyecci\xf3n inteligente de dependencias y gesti\xf3n de rutas de manera r\xe1pida y pr\xe1ctica."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:["GetX tiene 3 principios b\xe1sicos. Esto significa que estos son la prioridad para todos los recursos de la biblioteca: ",(0,s.jsx)(a.strong,{children:"PRODUCTIVIDAD, PERFORMANCIA Y ORGANIZACI\xd3N."})]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"PERFORMANCE:"})," GetX se centra en el rendimiento y el consumo m\xednimo de recursos. GetX no usa Streams o ChangeNotifier."]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"PRODUCTIVITY:"})," GetX utiliza una sintaxis f\xe1cil y agradable. No importa lo que quiera hacer, siempre hay una manera m\xe1s f\xe1cil con GetX. Ahorrar\xe1 horas de desarrollo y proporcionar\xe1 el m\xe1ximo rendimiento que su aplicaci\xf3n puede proporcionar."]}),"\n",(0,s.jsx)(a.p,{children:'Generalmente, el desarrollador deber\xeda preocuparse por eliminar los controladores de la memoria. Con GetX esto no es necesario porque los recursos se eliminan de la memoria cuando no son usados por defecto. Si desea conservarlo en la memoria, debe declarar expl\xedcitamente "permanente: true" en su dependencia. De esta manera, adem\xe1s de ahorrar tiempo, corremos menos riesgo de tener dependencias innecesarias en la memoria. La carga de dependencias tambi\xe9n es perezosa por defecto.'}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"ORGANIZACI\xd3N:"})," GetX permite el desacoplamiento total de la Vista, l\xf3gica de presentaci\xf3n, l\xf3gica de negocio, inyecci\xf3n de dependencias y navegaci\xf3n. No necesita contexto para navegar entre rutas, por lo que no depende del \xe1rbol de widgets (visualizaci\xf3n) para esto. No necesitas contexto para acceder a tus controladores/bloques a trav\xe9s de una herededWidget, por lo que desacoplas completamente tu l\xf3gica de presentaci\xf3n y l\xf3gica de negocio de tu capa de visualizaci\xf3n. No necesita inyectar las clases Controllers/Modelos/Blocs en su \xe1rbol de widgets a trav\xe9s de ",(0,s.jsx)(a.code,{children:"MultiProvider"}),"s. Para esto, GetX utiliza su propia caracter\xedstica de inyecci\xf3n de dependencias, desacoplando el DI desde su vista completamente."]}),"\n",(0,s.jsx)(a.p,{children:"Con GetX usted sabe d\xf3nde encontrar cada caracter\xedstica de su aplicaci\xf3n, teniendo c\xf3digo limpio de forma predeterminada. Adem\xe1s de facilitar el mantenimiento, esto hace que el intercambio de m\xf3dulos sea algo que hasta entonces en Flutter era impensable, algo totalmente posible.\nBLoC fue un punto de partida para organizar c\xf3digo en Flutter, separa la l\xf3gica de negocio de la visualizaci\xf3n. GetX es una evoluci\xf3n natural de esto, no s\xf3lo separando la l\xf3gica de negocio, sino tambi\xe9n la l\xf3gica de presentaci\xf3n. La inyecci\xf3n adicional de dependencias y rutas tambi\xe9n se desacoplan, y la capa de datos est\xe1 fuera de todo. Sabes d\xf3nde est\xe1 todo y todo esto de una manera m\xe1s f\xe1cil que construir un mundo feliz.\nGetX es la forma m\xe1s f\xe1cil, pr\xe1ctica y escalable de construir aplicaciones de alto rendimiento con el Flutter SDK. Tiene un gran ecosistema a su alrededor que funciona a la perfecci\xf3n, es f\xe1cil para los principiantes, y es preciso para los expertos. Es seguro, estable, actualizado, y ofrece una amplia gama de API integradas que no est\xe1n presentes en el SDK por defecto."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsx)(a.p,{children:"GetX no est\xe1 inflado. Tiene una multitud de caracter\xedsticas que te permiten comenzar a programar sin preocuparte de nada, pero cada una de estas caracter\xedsticas est\xe1n en contenedores separados y s\xf3lo se inician despu\xe9s de su uso. Si s\xf3lo utiliza la Administraci\xf3n del Estado, s\xf3lo se compilar\xe1 la Administraci\xf3n del Estado. Si usted s\xf3lo utiliza rutas, no se compilar\xe1 nada de la gesti\xf3n estatal."}),"\n"]}),"\n",(0,s.jsxs)(a.li,{children:["\n",(0,s.jsxs)(a.p,{children:["GetX tiene un enorme ecosistema, una gran comunidad, un gran n\xfamero de colaboradores, y se mantendr\xe1 mientras exista el Flutter. GetX tambi\xe9n es capaz de ejecutarse con el mismo c\xf3digo en Android, iOS, Web, Mac, Linux, Windows y en su servidor.\n",(0,s.jsxs)(a.strong,{children:["Es posible reutilizar completamente tu c\xf3digo hecho en el frontend de tu backend con ",(0,s.jsx)(a.a,{href:"https://github.com/jonataslaw/get_server",children:"Get Server"})]}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsxs)(a.strong,{children:["Adem\xe1s, todo el proceso de desarrollo puede ser completamente automatizado, tanto en el servidor como en el frontal con ",(0,s.jsx)(a.a,{href:"https://github.com/jonataslaw/get_cli",children:"Obtener CLI"})]}),"."]}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsxs)(a.strong,{children:["Adem\xe1s, para aumentar a\xfan m\xe1s tu productividad, tenemos la\n",(0,s.jsx)(a.a,{href:"https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets",children:"extensi\xf3n de VSCode"})," y la ",(0,s.jsx)(a.a,{href:"https://plugins.jetbrains.com/plugin/14975-getx-snippets",children:"extensi\xf3n de Android Studio/Intellij"})]})}),"\n",(0,s.jsx)(a.h2,{id:"por-qu\xe9-conseguir",children:"\xbfPor qu\xe9 conseguir?"}),"\n",(0,s.jsx)(a.p,{children:"1- Muchas veces despu\xe9s de una actualizaci\xf3n de Flutter, muchos de sus paquetes se romper\xe1n. A veces ocurren errores de compilaci\xf3n, a menudo aparecen errores de los que todav\xeda no hay respuestas, y el desarrollador necesita saber de d\xf3nde viene el error, rastrear el error, s\xf3lo entonces intente abrir un problema en el repositorio correspondiente, y vea su problema resuelto. Obtener centraliza los recursos principales para el desarrollo (gesti\xf3n de rutas), permitiendo a\xf1adir un solo paquete a tu pubspec, y empezar a trabajar. Despu\xe9s de una actualizaci\xf3n de Flutter, lo \xfanico que necesita hacer es actualizar la dependencia Obtener y ponerse a trabajar. Obtener tambi\xe9n resuelve problemas de compatibilidad. Cu\xe1ntas veces una versi\xf3n de un paquete no es compatible con la versi\xf3n de otra, porque uno usa una dependencia en una versi\xf3n, y el otro en otra versi\xf3n? Tampoco es una preocupaci\xf3n utilizar Get, ya que todo est\xe1 en el mismo paquete y es totalmente compatible."}),"\n",(0,s.jsxs)(a.p,{children:["2- Flutter es f\xe1cil, Flutter es incre\xedble, pero Flutter todav\xeda tiene algo de caldera que puede no ser deseado para la mayor\xeda de los desarrolladores, como ",(0,s.jsx)(a.code,{children:"Navigator. f(context).push (contexto, constructor [...]"}),". Obtener simplifica el desarrollo. En lugar de escribir 8 l\xedneas de c\xf3digo para simplemente llamar a una ruta, puedes hacerlo: ",(0,s.jsx)(a.code,{children:"Obtener. o(Home())"}),' y listo, ir\xe1s a la p\xe1gina siguiente. Las urls din\xe1micas de la web son algo realmente doloroso que ver con Flutter actualmente, y que con GetX es absurdamente simple. Gestionar estados en Flutter, y gestionar las dependencias tambi\xe9n es algo que genera mucha discusi\xf3n, ya que hay cientos de patrones en el pub. Pero no hay nada tan f\xe1cil como a\xf1adir un ". bs" al final de su variable, y colocar su widget dentro de un Obx, y eso es as\xed, todas las actualizaciones de esa variable se actualizar\xe1n autom\xe1ticamente en la pantalla.']}),"\n",(0,s.jsx)(a.p,{children:"3- \xdanete sin preocuparte por el rendimiento. El rendimiento de Flutter ya es sorprendente, pero imagina que usas un administrador de estado, y un localizador para distribuir tus clases, bloques/almacenes/controladores, etc. Tendr\xe1s que llamar manualmente a la exclusi\xf3n de esa dependencia cuando no la necesites. Pero \xbfalguna vez has pensado en usar simplemente tu controlador, y cuando ya no estaba siendo utilizado por nadie, simplemente se borrar\xeda de la memoria? Eso es lo que hace GetX. Con SmartManagement, todo lo que no se est\xe1 usando se borra de la memoria, y no deber\xeda tener que preocuparse por nada m\xe1s que programar. Estar\xe1n seguros de que est\xe1n consumiendo los recursos m\xednimos necesarios, sin ni siquiera haber creado una l\xf3gica para ello."}),"\n",(0,s.jsx)(a.p,{children:'4- Desacoplamiento real. Puede que haya escuchado el concepto "separar la vista de la l\xf3gica de negocio". Esto no es una pecularidad de BLoC, MVC, MVM, y cualquier otro est\xe1ndar en el mercado tiene este concepto. Sin embargo, este concepto puede mitigarse a menudo en Flutter debido al uso del contexto.\nSi necesita contexto para encontrar un inheritedWidget, lo necesita en la vista, o pasar el contexto por par\xe1metro. Me parece que esta soluci\xf3n es muy fea, y para trabajar en equipos siempre dependeremos de la l\xf3gica empresarial de View. Getx es poco ortodoxo con el enfoque est\xe1ndar, y aunque no proh\xedbe completamente el uso de StatefulWidgets, InitState, etc. siempre tiene un enfoque similar que puede ser m\xe1s limpio. Los controladores tienen ciclos de vida, y cuando necesita hacer una solicitud APIREST por ejemplo, no depende de nada en la vista. Puede usar onInit para iniciar la llamada http, y cuando los datos llegan, las variables se llenar\xe1n. Como GetX es completamente reactivo (realmente, y funciona bajo streams), una vez que los elementos son llenados, todos los widgets que usen esa variable se actualizar\xe1n autom\xe1ticamente en la vista. Esto permite a las personas con experiencia en la interfaz de usuario trabajar s\xf3lo con widgets, y no tiene que enviar nada a la l\xf3gica de negocio aparte de los eventos del usuario (como hacer clic en un bot\xf3n), mientras que la gente que trabaja con la l\xf3gica de negocios ser\xe1 libre de crear y probar la l\xf3gica de negocio por separado.'}),"\n",(0,s.jsx)(a.p,{children:"Esta biblioteca siempre se actualizar\xe1 e implementar\xe1 nuevas caracter\xedsticas. Si\xe9ntase libre de ofrecer PRs y contribuir a ellos."})]})}function u(e={}){const{wrapper:a}={...(0,o.a)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,a,n)=>{n.d(a,{Z:()=>i,a:()=>t});var s=n(7294);const o={},r=s.createContext(o);function t(e){const a=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:a},e.children)}}}]);