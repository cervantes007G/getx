"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[39],{6193:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>d});var s=a(5893),i=a(1151);const t={sidebar_position:3},r="Dependencia",l={id:"pillars/dependency-management",title:"Dependencia",description:"Get tiene un gestor de dependencias simple y potente que te permite recuperar la misma clase que tu Bloc o Controlador con solo 1 l\xednea de c\xf3digo, sin contexto de proveedores, sin inheritedWidget:",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/pillars/dependency-management.md",sourceDirName:"pillars",slug:"/pillars/dependency-management",permalink:"/getx/es/docs/pillars/dependency-management",draft:!1,unlisted:!1,editUrl:"https://github.com/jonataslaw/getx/docs/pillars/dependency-management.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Ruta",permalink:"/getx/es/docs/pillars/route-management"},next:{title:"Utils",permalink:"/getx/es/docs/utils"}},o={},d=[{value:"M\xe9todos de Instancia",id:"m\xe9todos-de-instancia",level:2},{value:"Get.put()",id:"getput",level:3},{value:"Get.lazyPut",id:"getlazyput",level:3},{value:"Get.putAsync",id:"getputasync",level:3},{value:"Get.create",id:"getcreate",level:3},{value:"Usando m\xe9todos/clases instanciadas",id:"usando-m\xe9todosclases-instanciadas",level:2},{value:"Especificar una instancia alternativa",id:"especificar-una-instancia-alternativa",level:2},{value:"Diferencias entre m\xe9todos",id:"diferencias-entre-m\xe9todos",level:2},{value:"Enlaces",id:"enlaces",level:2},{value:"Clase de enlaces",id:"clase-de-enlaces",level:3},{value:"Constructor de enlaces",id:"constructor-de-enlaces",level:3},{value:"Gesti\xf3n inteligente",id:"gesti\xf3n-inteligente",level:3},{value:"C\xf3mo cambiar",id:"c\xf3mo-cambiar",level:4},{value:"SmartManagement.full",id:"smartmanagementfull",level:4},{value:"SmartManagement.onlyBuilder",id:"smartmanagementonlybuilder",level:4},{value:"SmartManagement.keepFactory",id:"smartmanagementkeepfactory",level:4},{value:"C\xf3mo funcionan los enlaces bajo el cap\xf3",id:"c\xf3mo-funcionan-los-enlaces-bajo-el-cap\xf3",level:3},{value:"Notas",id:"notas",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"dependencia",children:"Dependencia"}),"\n",(0,s.jsx)(n.p,{children:"Get tiene un gestor de dependencias simple y potente que te permite recuperar la misma clase que tu Bloc o Controlador con solo 1 l\xednea de c\xf3digo, sin contexto de proveedores, sin inheritedWidget:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Controller controller = Get.put(Controller()); // Rather Controller controller = Controller();\n"})}),"\n",(0,s.jsx)(n.p,{children:"En lugar de instanciar su clase dentro de la clase que est\xe1 usando, lo instancias dentro de la instancia Obt\xe9ngala, que lo har\xe1 disponible a trav\xe9s de tu aplicaci\xf3n.\nAs\xed que puedes usar tu controlador (o clase Bloc) normalmente"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Nota: Si est\xe1s usando Get's State Manager, presta m\xe1s atenci\xf3n a la app ",(0,s.jsx)(n.a,{href:"#bindings",children:"Bindings"}),", lo que har\xe1 m\xe1s f\xe1cil conectar tu vista a tu controlador."]}),"\n",(0,s.jsx)(n.li,{children:"Nota2: Obtener la gesti\xf3n de dependencias es desglosado de otras partes del paquete, as\xed que si por ejemplo tu aplicaci\xf3n ya est\xe1 usando un administrador de estado (cualquier otro, no importa), no necesitas cambiar eso, puedes usar este gestor de inyecci\xf3n de dependencias sin ning\xfan problema"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"m\xe9todos-de-instancia",children:"M\xe9todos de Instancia"}),"\n",(0,s.jsx)(n.p,{children:"Los m\xe9todos y sus par\xe1metros configurables son:"}),"\n",(0,s.jsx)(n.h3,{id:"getput",children:"Get.put()"}),"\n",(0,s.jsx)(n.p,{children:"La forma m\xe1s com\xfan de insertar una dependencia. Bueno para los controladores de tus vistas, por ejemplo."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'Get.put<SomeClass>(SomeClass());\nGet.put<LoginController>(LoginController(), permanent: true);\nGet.put<ListItemController>(ListItemController, tag: "some unique string");\n'})}),"\n",(0,s.jsx)(n.p,{children:"Esto es todas las opciones que se pueden establecer al usar put:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'Get.put<S>(\n  // mandatory: the class that you want to get to save, like a controller or anything\n  // note: "S" means that it can be a class of any type\n  S dependency\n\n  // optional: this is for when you want multiple classess that are of the same type\n  // since you normally get a class by using Get.find<Controller>(),\n  // you need to use tag to tell which instance you need\n  // must be unique string\n  String tag,\n\n  // optional: by default, get will dispose instances after they are not used anymore (example,\n  // the controller of a view that is closed), but you might need that the instance\n  // to be kept there throughout the entire app, like an instance of sharedPreferences or something\n  // so you use this\n  // defaults to false\n  bool permanent = false,\n\n  // optional: allows you after using an abstract class in a test, replace it with another one and follow the test.\n  // defaults to false\n  bool overrideAbstract = false,\n\n  // optional: allows you to create the dependency using function instead of the dependency itself.\n  // this one is not commonly used\n  InstanceBuilderCallback<S> builder,\n)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getlazyput",children:"Get.lazyPut"}),"\n",(0,s.jsx)(n.p,{children:"Es posible lazyLoad una dependencia para que se instancie s\xf3lo cuando se use. Muy \xfatil para clases caras computacionales o si desea instanciar varias clases en un solo lugar (como en una clase Bindings) y sabe que no va a utilizar esa clase en ese momento."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"/// ApiMock will only be called when someone uses Get.find<ApiMock> for the first time\nGet.lazyPut<ApiMock>(() => ApiMock());\n\nGet.lazyPut<FirebaseAuth>(\n  () {\n    // ... some logic if needed\n    return FirebaseAuth();\n  },\n  tag: Math.random().toString(),\n  fenix: true\n)\n\nGet.lazyPut<Controller>( () => Controller() )\n"})}),"\n",(0,s.jsx)(n.p,{children:"Esta es todas las opciones que puedes establecer al usar lazyPut:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'Get.lazyPut<S>(\n  // mandatory: a method that will be executed when your class is called for the first time\n  InstanceBuilderCallback builder,\n  \n  // optional: same as Get.put(), it is used for when you want multiple different instance of a same class\n  // must be unique\n  String tag,\n\n  // optional: It is similar to "permanent", the difference is that the instance is discarded when\n  // is not being used, but when it\'s use is needed again, Get will recreate the instance\n  // just the same as "SmartManagement.keepFactory" in the bindings api\n  // defaults to false\n  bool fenix = false\n  \n)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getputasync",children:"Get.putAsync"}),"\n",(0,s.jsxs)(n.p,{children:["Si desea registrar una instancia as\xedncrona, puede utilizar ",(0,s.jsx)(n.code,{children:"Get.putAsync"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Get.putAsync<SharedPreferences>(() async {\n  final prefs = await SharedPreferences.getInstance();\n  await prefs.setInt('counter', 12345);\n  return prefs;\n});\n\nGet.putAsync<YourAsyncClass>( () async => await YourAsyncClass() )\n"})}),"\n",(0,s.jsx)(n.p,{children:"Esto es todas las opciones que se pueden establecer cuando se utiliza putAsync:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Get.putAsync<S>(\n\n  // mandatory: an async method that will be executed to instantiate your class\n  AsyncInstanceBuilderCallback<S> builder,\n\n  // optional: same as Get.put(), it is used for when you want multiple different instance of a same class\n  // must be unique\n  String tag,\n\n  // optional: same as in Get.put(), used when you need to maintain that instance alive in the entire app\n  // defaults to false\n  bool permanent = false\n)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"getcreate",children:"Get.create"}),"\n",(0,s.jsxs)(n.p,{children:["Este es complicado. Una explicaci\xf3n detallada de lo que es esto y de las diferencias entre el otro se puede encontrar en la secci\xf3n ",(0,s.jsx)(n.a,{href:"#differences-between-methods",children:"Diferencias entre m\xe9todos:"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Get.Create<SomeClass>(() => SomeClass());\nGet.Create<LoginController>(() => LoginController());\n"})}),"\n",(0,s.jsx)(n.p,{children:"Estas son todas las opciones que puedes establecer al usar create:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:'Get.create<S>(\n  // required: a function that returns a class that will be "fabricated" every\n  // time `Get.find()` is called\n  // Example: Get.create<YourClass>(() => YourClass())\n  FcBuilderFunc<S> builder,\n\n  // optional: just like Get.put(), but it is used when you need multiple instances\n  // of a of a same class\n  // Useful in case you have a list that each item need it\'s own controller\n  // needs to be a unique string. Just change from tag to name\n  String name,\n\n  // optional: just like int`Get.put()`, it is for when you need to keep the\n  // instance alive thoughout the entire app. The difference is in Get.create\n  // permanent is true by default\n  bool permanent = true\n'})}),"\n",(0,s.jsx)(n.h2,{id:"usando-m\xe9todosclases-instanciadas",children:"Usando m\xe9todos/clases instanciadas"}),"\n",(0,s.jsx)(n.p,{children:'Imagina que has navegado a trav\xe9s de numerosas rutas, y necesitas un dato que se haya dejado atr\xe1s en tu controlador, Necesitar\xeda un administrador estatal combinado con el Proveedor o Get_it, \xbfcorrecto? No con obtener. S\xf3lo necesitas preguntar Get to "encontrd" para tu controlador, no necesitas ninguna dependencia adicional:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final controller = Get.find<Controller>();\n// OR\nController controller = Get.find();\n\n// Yes, it looks like Magic, Get will find your controller, and will deliver it to you.\n// You can have 1 million controllers instantiated, Get will always give you the right controller.\n"})}),"\n",(0,s.jsx)(n.p,{children:"Y entonces podr\xe1s recuperar los datos de tu controlador que se obtuvieron de vuelta all\xed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Text(controller.textFromApi);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Dado que el valor devuelto es una clase normal, puedes hacer lo que quieras:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"int count = Get.find<SharedPreferences>().getInt('counter');\nprint(count); // out: 12345\n"})}),"\n",(0,s.jsx)(n.p,{children:"Para remover una instancia de Get:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Get.delete<Controller>(); //usually you don't need to do this because GetX already delete unused controllers\n"})}),"\n",(0,s.jsx)(n.h2,{id:"especificar-una-instancia-alternativa",children:"Especificar una instancia alternativa"}),"\n",(0,s.jsxs)(n.p,{children:["Una instancia actualmente insertada puede ser reemplazada con una instancia de clase similar o extendida usando el m\xe9todo ",(0,s.jsx)(n.code,{children:"replace"})," o ",(0,s.jsx)(n.code,{children:"lazyReplace"}),". Esto puede ser recuperado usando la clase original."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"abstract class BaseClass {}\nclass ParentClass extends BaseClass {}\n\nclass ChildClass extends ParentClass {\n  bool isChild = true;\n}\n\n\nGet.put<BaseClass>(ParentClass());\n\nGet.replace<BaseClass>(ChildClass());\n\nfinal instance = Get.find<BaseClass>();\nprint(instance is ChildClass); //true\n\n\nclass OtherClass extends BaseClass {}\nGet.lazyReplace<BaseClass>(() => OtherClass());\n\nfinal instance = Get.find<BaseClass>();\nprint(instance is ChildClass); // false\nprint(instance is OtherClass); //true\n"})}),"\n",(0,s.jsx)(n.h2,{id:"diferencias-entre-m\xe9todos",children:"Diferencias entre m\xe9todos"}),"\n",(0,s.jsx)(n.p,{children:'Primero, vamos al "fenix" de Get.lazyPut y al "permanente" de los otros m\xe9todos.'}),"\n",(0,s.jsxs)(n.p,{children:["La diferencia fundamental entre ",(0,s.jsx)(n.code,{children:"permanent"})," y ",(0,s.jsx)(n.code,{children:"fenix"})," es c\xf3mo quieres almacenar tus instancias."]}),"\n",(0,s.jsxs)(n.p,{children:["Refuerzo: por defecto, GetX elimina las instancias cuando no est\xe1n en uso.\nSignifica que: Si la pantalla 1 tiene el controlador 1 y la pantalla 2 tiene el controlador 2 y se quita la primera ruta de la pila, (como si usas ",(0,s.jsx)(n.code,{children:"Obtener. ff()"})," o ",(0,s.jsx)(n.code,{children:"Get.offNamed()"}),") el controlador 1 perdi\xf3 su uso por lo que ser\xe1 borrado."]}),"\n",(0,s.jsxs)(n.p,{children:["Pero si quieres optar por usar ",(0,s.jsx)(n.code,{children:"permanent:true"}),", entonces el controlador no se perder\xe1 en esta transici\xf3n - que es muy \xfatil para los servicios que desea mantener vivo a lo largo de toda la aplicaci\xf3n."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fenix"}),' en la otra mano es para servicios que no te preocupas al perder entre los cambios de pantalla, pero cuando usted necesita ese servicio, usted espera que est\xe9 vivo. B\xe1sicamente, dispondr\xe1 el controlador/servicio/clase/clase no utilizado, pero cuando lo necesite, "recrear\xe1 desde las ashes" una nueva instancia.']}),"\n",(0,s.jsx)(n.p,{children:"Continuando con las diferencias entre m\xe9todos:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Get.put y Get. utAsync sigue el mismo orden de creaci\xf3n, con la diferencia de que el segundo utiliza un m\xe9todo as\xedncrono: esos dos m\xe9todos crean e inicializan la instancia. Que uno se inserta directamente en la memoria, usando el m\xe9todo interno ",(0,s.jsx)(n.code,{children:"insert"})," con los par\xe1metros ",(0,s.jsx)(n.code,{children:"permanente: false"})," y ",(0,s.jsx)(n.code,{children:"isSingleton: true"})," (este par\xe1metro isSingleton s\xf3lo tiene el prop\xf3sito de indicar si es para usar la dependencia de ",(0,s.jsx)(n.code,{children:"dependency"})," o si es para usar la dependencia de ",(0,s.jsx)(n.code,{children:"FcBuilderFunc"}),"). Despu\xe9s de eso, ",(0,s.jsx)(n.code,{children:"Get.find()"})," es llamado que inmediatamente inicializa las instancias que est\xe1n en memoria."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['Get.create: \xa1Como su nombre lo implica, "crear\xe1" su dependencia! Similar a ',(0,s.jsx)(n.code,{children:"Get.put()"}),", tambi\xe9n llama al m\xe9todo interno ",(0,s.jsx)(n.code,{children:"insert"})," para instanciar. Pero ",(0,s.jsx)(n.code,{children:"permanent"})," se hizo cierto y ",(0,s.jsx)(n.code,{children:"isSingleton"}),' se volvi\xf3 falso (ya que estamos "creando" nuestra dependencia, no hay manera de que sea una instancia singleton, por eso es falso). Y porque tiene ',(0,s.jsx)(n.code,{children:"permanente: true"}),", tenemos por defecto el beneficio de no perderlo entre las pantallas! Adem\xe1s, ",(0,s.jsx)(n.code,{children:"Get.find()"})," no se llama inmediatamente, espera a ser usado en la pantalla para ser llamado. Se crea de esta manera para hacer uso del par\xe1metro ",(0,s.jsx)(n.code,{children:"permanent"}),", desde entonces, vale la pena observar, ",(0,s.jsx)(n.code,{children:"Obtener. reate()"})," se hizo con el objetivo de crear instancias no compartidas, pero no eliminar, como por ejemplo un bot\xf3n en una listView, que desea una instancia \xfanica para esa lista - por eso, Obtener. reate debe ser utilizado junto con GetWidget."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Get.lazyPut: Como su nombre implica, es un proceso perezoso. La instancia es creada, pero no es llamada para ser utilizada inmediatamente, permanece esperando a ser llamada. Contrario a los otros m\xe9todos, ",(0,s.jsx)(n.code,{children:"insert"}),' no es llamado aqu\xed. En su lugar, la instancia se inserta en otra parte de la memoria, una parte responsable de decir si la instancia puede ser recreada o no, llam\xe9mosla "f\xe1brica". Si queremos crear algo que se utilice m\xe1s tarde, no se mezclar\xe1 con las cosas que se han utilizado en este momento. Y aqu\xed es donde entra la magia de ',(0,s.jsx)(n.code,{children:"fenix"}),": si optas por dejar ",(0,s.jsx)(n.code,{children:"fenix: false"}),", y tu ",(0,s.jsx)(n.code,{children:"smartManagement"})," no son ",(0,s.jsx)(n.code,{children:"keepFactory"}),", entonces cuando usas ",(0,s.jsx)(n.code,{children:"Get. ind"}),' la instancia cambiar\xe1 el lugar en la memoria de la "f\xe1brica" al \xe1rea de memoria de instancia com\xfan. Justo despu\xe9s de eso, por defecto se elimina de la "f\xe1brica". Ahora, si optas por ',(0,s.jsx)(n.code,{children:"fenix: true"}),", la instancia sigue existiendo en esta parte dedicada, ir incluso al espacio com\xfan para ser llamado de nuevo en el futuro."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"enlaces",children:"Enlaces"}),"\n",(0,s.jsx)(n.p,{children:'Una de las grandes diferencias de este paquete, tal vez, es la posibilidad de la plena integraci\xf3n de las rutas, el administrador del estado y el gestor de dependencias.\nCuando una ruta es removida de la pila, todos los controladores, variables e instancias de objetos relacionados con ella son removidos de la memoria. Si est\xe1 usando secuencias o temporizadores, se cerrar\xe1n autom\xe1ticamente, y no tiene que preocuparse por nada de eso.\nEn la versi\xf3n 2.10 Obtenga la implementaci\xf3n completa de la API Bindings.\nAhora ya no necesita utilizar el m\xe9todo init. Ni siquiera tienes que escribir tus controladores si no quieres. Puedes iniciar tus controladores y servicios en el lugar apropiado para ello.\nLa clase Binding es una clase que desacoplar\xe1 la inyecci\xf3n de dependencias, mientras que las rutas "vinculantes" al administrador de estado y al gestor de dependencias.\nEsto le permite a Get saber qu\xe9 pantalla se muestra cuando se utiliza un controlador en particular y saber d\xf3nde y c\xf3mo eliminarlo.\nAdem\xe1s, la clase Binding le permitir\xe1 tener el control de configuraci\xf3n de SmartManager. Puede configurar las dependencias a organizar al eliminar una ruta de la pila, o cuando el widget que lo us\xf3 est\xe1 dispuesto, o ninguna de las dos. Tendr\xe1s una gesti\xf3n inteligente de dependencias trabajando para ti, pero a\xfan as\xed, puedes configurarla como quieras.'}),"\n",(0,s.jsx)(n.h3,{id:"clase-de-enlaces",children:"Clase de enlaces"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Crear una clase e implementa Binding"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class HomeBinding implements Bindings {}\n"})}),"\n",(0,s.jsx)(n.p,{children:'Su IDE autom\xe1ticamente le pedir\xe1 que reemplace el m\xe9todo "dependencias" y s\xf3lo necesita hacer clic en la l\xe1mpara, sobreescribir el m\xe9todo, e insertar todas las clases que va a utilizar en esa ruta:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class HomeBinding implements Bindings {\n  @override\n  void dependencies() {\n    Get.lazyPut<HomeController>(() => HomeController());\n    Get.put<Service>(()=> Api());\n  }\n}\n\nclass DetailsBinding implements Bindings {\n  @override\n  void dependencies() {\n    Get.lazyPut<DetailsController>(() => DetailsController());\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Ahora s\xf3lo necesita informar a su ruta, que utilizar\xe1 ese enlace para hacer la conexi\xf3n entre el gestor de rutas, las dependencias y los estados."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Usando rutas nombradas:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"getPages: [\n  GetPage(\n    name: '/',\n    page: () => HomeView(),\n    binding: HomeBinding(),\n  ),\n  GetPage(\n    name: '/details',\n    page: () => DetailsView(),\n    binding: DetailsBinding(),\n  ),\n];\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Usando rutas normales:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Get.to(Home(), binding: HomeBinding());\nGet.to(DetailsView(), binding: DetailsBinding())\n"})}),"\n",(0,s.jsx)(n.p,{children:"All\xed, ya no tienes que preocuparte por la administraci\xf3n de memoria de tu aplicaci\xf3n. Get lo har\xe1 por ti."}),"\n",(0,s.jsx)(n.p,{children:'La clase Binding es llamada cuando se llama a una ruta, puedes crear un "initialBinding en tu GetMaterialApp para insertar todas las dependencias que se crear\xe1n.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"GetMaterialApp(\n  initialBinding: SampleBind(),\n  home: Home(),\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"constructor-de-enlaces",children:"Constructor de enlaces"}),"\n",(0,s.jsxs)(n.p,{children:["La forma predeterminada de crear un enlace es creando una clase que implemente Bindings.\nPero alternativamente, puedes usar el callback ",(0,s.jsx)(n.code,{children:"BindingsBuilder"})," para que puedas simplemente usar una funci\xf3n para instanciar lo que desees."]}),"\n",(0,s.jsx)(n.p,{children:"Ejemplo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"getPages: [\n  GetPage(\n    name: '/',\n    page: () => HomeView(),\n    binding: BindingsBuilder(() {\n      Get.lazyPut<ControllerX>(() => ControllerX());\n      Get.put<Service>(()=> Api());\n    }),\n  ),\n  GetPage(\n    name: '/details',\n    page: () => DetailsView(),\n    binding: BindingsBuilder(() {\n      Get.lazyPut<DetailsController>(() => DetailsController());\n    }),\n  ),\n];\n"})}),"\n",(0,s.jsx)(n.p,{children:"De esta manera puede evitar crear una clase Binding para cada ruta, haciendo esto a\xfan m\xe1s sencillo."}),"\n",(0,s.jsx)(n.p,{children:"Ambas formas de trabajar perfectamente y queremos que usted utilice lo que m\xe1s se adapte a sus gustos."}),"\n",(0,s.jsx)(n.h3,{id:"gesti\xf3n-inteligente",children:"Gesti\xf3n inteligente"}),"\n",(0,s.jsxs)(n.p,{children:["GetX por defecto dispone de controladores no utilizados de la memoria, incluso si ocurre un fallo y un widget que lo usa no est\xe1 correctamente eliminado.\nEsto es lo que se llama el modo 'completo' de gesti\xf3n de dependencias.\nPero si quieres cambiar la forma en que GetX controla la eliminaci\xf3n de clases, tienes la clase ",(0,s.jsx)(n.code,{children:"SmartManagement"})," que puedes establecer diferentes comportamientos."]}),"\n",(0,s.jsx)(n.h4,{id:"c\xf3mo-cambiar",children:"C\xf3mo cambiar"}),"\n",(0,s.jsx)(n.p,{children:"Si desea cambiar esta configuraci\xf3n (que normalmente no necesita) esta es la manera:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"void main () {\n  runApp(\n    GetMaterialApp(\n      smartManagement: SmartManagement.onlyBuilder //here\n      home: Home(),\n    )\n  )\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"smartmanagementfull",children:"SmartManagement.full"}),"\n",(0,s.jsx)(n.p,{children:"Es el predeterminado. Descartar las clases que no est\xe1n siendo usadas y que no est\xe1n configuradas como permanentes. En la mayor\xeda de los casos querr\xe1 mantener esta configuraci\xf3n sin tocar. Si usted es nuevo en GetX entonces no cambie esto."}),"\n",(0,s.jsx)(n.h4,{id:"smartmanagementonlybuilder",children:"SmartManagement.onlyBuilder"}),"\n",(0,s.jsxs)(n.p,{children:["Con esta opci\xf3n, s\xf3lo se eliminar\xe1n los controladores iniciados en ",(0,s.jsx)(n.code,{children:"init:"})," o cargados en un enlace con ",(0,s.jsx)(n.code,{children:"Get.lazyPut()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Si utiliza ",(0,s.jsx)(n.code,{children:"Get.put()"})," o ",(0,s.jsx)(n.code,{children:"Get.putAsync()"})," o cualquier otro enfoque, SmartManagement no tendr\xe1 permisos para excluir esta dependencia."]}),"\n",(0,s.jsx)(n.p,{children:'Con el comportamiento por defecto, incluso los widgets instanciados con "Get.put" ser\xe1n eliminados, a diferencia de SmartManagement.onlyBuilder.'}),"\n",(0,s.jsx)(n.h4,{id:"smartmanagementkeepfactory",children:"SmartManagement.keepFactory"}),"\n",(0,s.jsx)(n.p,{children:"Al igual que SmartManagement.full, eliminar\xe1 sus dependencias cuando ya no se est\xe9 usando. Sin embargo, mantendr\xe1 su f\xe1brica, lo que significa que recrear\xe1 la dependencia si se necesita esa instancia de nuevo."}),"\n",(0,s.jsx)(n.h3,{id:"c\xf3mo-funcionan-los-enlaces-bajo-el-cap\xf3",children:"C\xf3mo funcionan los enlaces bajo el cap\xf3"}),"\n",(0,s.jsx)(n.p,{children:'Los enlaces crean f\xe1bricas de transitorio, que se crean en el momento en que hace clic para ir a otra pantalla, y ser\xe1 destruido tan pronto como ocurra la animaci\xf3n de cambio de pantalla.\nEsto sucede tan r\xe1pido que el analizador ni siquiera ser\xe1 capaz de registrarlo.\nCuando navega a esta pantalla de nuevo, se llamar\xe1 a una nueva f\xe1brica temporal, por lo que es preferible usar SmartManagement. eepFactory, pero si no quieres crear enlaces, o quieres mantener todas tus dependencias en el mismo enlace, seguramente te ayudar\xe1.\nLas f\xe1bricas ocupan poca memoria, no guardan las instancias, sino una funci\xf3n con la "forma" de la clase que quieras.\nEsto tiene un costo muy bajo en la memoria, pero dado que el prop\xf3sito de esta librer\xeda es obtener el m\xe1ximo rendimiento posible utilizando los recursos m\xednimos, Obtener elimina incluso las f\xe1bricas de forma predeterminada.\nUtilice el que m\xe1s le convenga.'}),"\n",(0,s.jsx)(n.h2,{id:"notas",children:"Notas"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"NO USE SmartManagement.keepFactory si est\xe1 utilizando m\xfaltiples enlaces. Ha sido dise\xf1ado para ser utilizado sin enlaces, o con un solo enlazado en el initialBinding de GetMaterialApp."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Usar enlaces es completamente opcional, si lo deseas, puedes usar ",(0,s.jsx)(n.code,{children:"Get.put()"})," y ",(0,s.jsx)(n.code,{children:"Get.find()"})," en clases que usan un controlador dado sin ning\xfan problema.\nSin embargo, si usted trabaja con Servicios o cualquier otra abstracci\xf3n, recomiendo usar Bindings para una mejor organizaci\xf3n."]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>l,a:()=>r});var s=a(7294);const i={},t=s.createContext(i);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);