"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[813],{7963:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(5893),i=t(1151);const o={sidebar_position:1},s="State",r={id:"pillars/state-management",title:"State",description:"GetX does not use Streams or ChangeNotifier like other state managers. Why? In addition to building applications for android, iOS, web, windows, macos and linux, with GetX you can build server applications with the same syntax as Flutter/GetX. In order to improve response time and reduce RAM consumption, we created GetValue and GetStream, which are low latency solutions that deliver a lot of performance, at a low operating cost. We use this base to build all of our resources, including state management.",source:"@site/docs/pillars/state-management.md",sourceDirName:"pillars",slug:"/pillars/state-management",permalink:"/getx/docs/pillars/state-management",draft:!1,unlisted:!1,editUrl:"https://github.com/jonataslaw/getx/docs/pillars/state-management.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"The 3 Pillars",permalink:"/getx/docs/category/the-3-pillars"},next:{title:"Route",permalink:"/getx/docs/pillars/route-management"}},l={},d=[{value:"Reactive State Manager",id:"reactive-state-manager",level:2},{value:"Advantages",id:"advantages",level:3},{value:"Maximum performance:",id:"maximum-performance",level:3},{value:"Declaring a reactive variable",id:"declaring-a-reactive-variable",level:3},{value:"Having a reactive state, is easy.",id:"having-a-reactive-state-is-easy",level:5},{value:"Using the values in the view",id:"using-the-values-in-the-view",level:3},{value:"Conditions to rebuild",id:"conditions-to-rebuild",level:3},{value:"Where .obs can be used",id:"where-obs-can-be-used",level:3},{value:"Note about Lists",id:"note-about-lists",level:3},{value:"Why i have to use .value",id:"why-i-have-to-use-value",level:3},{value:"Obx()",id:"obx",level:3},{value:"Workers",id:"workers",level:3},{value:"Simple State Manager",id:"simple-state-manager",level:2},{value:"Advantages",id:"advantages-1",level:3},{value:"Usage",id:"usage",level:3},{value:"How it handles controllers",id:"how-it-handles-controllers",level:3},{value:"You won&#39;t need StatefulWidgets anymore",id:"you-wont-need-statefulwidgets-anymore",level:3},{value:"Why it exists",id:"why-it-exists",level:3},{value:"Other ways of using it",id:"other-ways-of-using-it",level:3},{value:"Unique IDs",id:"unique-ids",level:3},{value:"Mixing the two state managers",id:"mixing-the-two-state-managers",level:2},{value:"StateMixin",id:"statemixin",level:2},{value:"GetBuilder vs GetX vs Obx vs MixinBuilder",id:"getbuilder-vs-getx-vs-obx-vs-mixinbuilder",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"state",children:"State"}),"\n",(0,a.jsx)(n.p,{children:"GetX does not use Streams or ChangeNotifier like other state managers. Why? In addition to building applications for android, iOS, web, windows, macos and linux, with GetX you can build server applications with the same syntax as Flutter/GetX. In order to improve response time and reduce RAM consumption, we created GetValue and GetStream, which are low latency solutions that deliver a lot of performance, at a low operating cost. We use this base to build all of our resources, including state management."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Complexity"}),": Some state managers are complex and have a lot of boilerplate. With GetX you don't have to define a class for each event, the code is highly clean and clear, and you do a lot more by writing less. Many people have given up on Flutter because of this topic, and they now finally have a stupidly simple solution for managing states."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"No code generators"}),": You spend half your development time writing your application logic. Some state managers rely on code generators to have minimally readable code. Changing a variable and having to run build_runner can be unproductive, and often the waiting time after a flutter clean will be long, and you will have to drink a lot of coffee."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With GetX everything is reactive, and nothing depends on code generators, increasing your productivity in all aspects of your development."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"It does not depend on context"}),": You probably already needed to send the context of your view to a controller, making the View's coupling with your business logic high. You have probably had to use a dependency for a place that has no context, and had to pass the context through various classes and functions. This just doesn't exist with GetX. You have access to your controllers from within your controllers without any context. You don't need to send the context by parameter for literally nothing."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"Granular control"}),": most state managers are based on ChangeNotifier. ChangeNotifier will notify all widgets that depend on it when notifyListeners is called. If you have 40 widgets on one screen, which have a variable of your ChangeNotifier class, when you update one, all of them will be rebuilt."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With GetX, even nested widgets are respected. If you have Obx watching your ListView, and another watching a checkbox inside the ListView, when changing the CheckBox value, only it will be updated, when changing the List value, only the ListView will be updated."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.em,{children:"It only reconstructs if its variable REALLY changes"}),": GetX has flow control, that means if you display a Text with 'Paola', if you change the observable variable to 'Paola' again, the widget will not be reconstructed. That's because GetX knows that 'Paola' is already being displayed in Text, and will not do unnecessary reconstructions."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Most (if not all) current state managers will rebuild on the screen."}),"\n",(0,a.jsx)(n.h2,{id:"reactive-state-manager",children:"Reactive State Manager"}),"\n",(0,a.jsx)(n.p,{children:"Reactive programming can alienate many people because it is said to be complicated. GetX turns reactive programming into something quite simple:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"You won't need to create StreamControllers."}),"\n",(0,a.jsx)(n.li,{children:"You won't need to create a StreamBuilder for each variable"}),"\n",(0,a.jsx)(n.li,{children:"You will not need to create a class for each state."}),"\n",(0,a.jsx)(n.li,{children:"You will not need to create a get for an initial value."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Reactive programming with Get is as easy as using setState."}),"\n",(0,a.jsx)(n.p,{children:"Let's imagine that you have a name variable and want that every time you change it, all widgets that use it are automatically changed."}),"\n",(0,a.jsx)(n.p,{children:"This is your count variable:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"var name = 'Jonatas Borges';\n"})}),"\n",(0,a.jsx)(n.p,{children:'To make it observable, you just need to add ".obs" to the end of it:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"var name = 'Jonatas Borges'.obs;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["That's all. It's ",(0,a.jsx)(n.em,{children:"that"})," simple."]}),"\n",(0,a.jsxs)(n.p,{children:['From now on, we might refer to this reactive-".obs"(ervables) variables as ',(0,a.jsx)(n.em,{children:"Rx"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["What did we do under the hood? We created a ",(0,a.jsx)(n.code,{children:"Stream"})," of ",(0,a.jsx)(n.code,{children:"String"})," s, assigned the initial value ",(0,a.jsx)(n.code,{children:'"Jonatas Borges"'})," , we notified all widgets that use ",(0,a.jsx)(n.code,{children:'"Jonatas Borges"'}),' that they now "belong" to this variable, and when the ',(0,a.jsx)(n.em,{children:"Rx"})," value changes, they will have to change as well."]}),"\n",(0,a.jsxs)(n.p,{children:["This is the ",(0,a.jsx)(n.strong,{children:"magic of GetX"}),", thanks to Dart's capabilities."]}),"\n",(0,a.jsxs)(n.p,{children:["But, as we know, a ",(0,a.jsx)(n.code,{children:"Widget"}),' can only be changed if it is inside a function, because static classes do not have the power to "auto-change".']}),"\n",(0,a.jsxs)(n.p,{children:["You will need to create a ",(0,a.jsx)(n.code,{children:"StreamBuilder"}),' , subscribe to this variable to listen for changes, and create a "cascade" of nested ',(0,a.jsx)(n.code,{children:"StreamBuilder"})," if you want to change several variables in the same scope, right?"]}),"\n",(0,a.jsxs)(n.p,{children:["No, you don't need a ",(0,a.jsx)(n.code,{children:"StreamBuilder"})," , but you are right about static classes."]}),"\n",(0,a.jsxs)(n.p,{children:["Well, in the view, we usually have a lot of boilerplate when we want to change a specific Widget, that's the Flutter way.\nWith ",(0,a.jsx)(n.strong,{children:"GetX"})," you can also forget about this boilerplate code."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"StreamBuilder( \u2026 )"})," ? ",(0,a.jsx)(n.code,{children:"initialValue: \u2026"})," ? ",(0,a.jsx)(n.code,{children:"builder: \u2026"})," ? Nope, you just need to place this variable inside an ",(0,a.jsx)(n.code,{children:"Obx()"})," Widget."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Obx (() => Text (controller.name));\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.em,{children:"What do you need to memorize?"}),"  Only ",(0,a.jsx)(n.code,{children:"Obx(() =>"})," ."]}),"\n",(0,a.jsxs)(n.p,{children:["You are just passing that Widget through an arrow-function into an ",(0,a.jsx)(n.code,{children:"Obx()"}),' (the "Observer" of the ',(0,a.jsx)(n.em,{children:"Rx"}),")."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Obx"})," is pretty smart, and will only change if the value of ",(0,a.jsx)(n.code,{children:"controller.name"})," changes."]}),"\n",(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"name"})," is ",(0,a.jsx)(n.code,{children:'"John"'})," , and you change it to ",(0,a.jsx)(n.code,{children:'"John"'})," ( ",(0,a.jsx)(n.code,{children:'name.value = "John"'})," ), as it's the same ",(0,a.jsx)(n.code,{children:"value"})," as before, nothing will change on the screen, and ",(0,a.jsx)(n.code,{children:"Obx"})," , to save resources, will simply ignore the new value and not rebuild the Widget. ",(0,a.jsx)(n.strong,{children:"Isn't that amazing?"})]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["So, what if I have 5 ",(0,a.jsx)(n.em,{children:"Rx"})," (observable) variables within an ",(0,a.jsx)(n.code,{children:"Obx"})," ?"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["It will just update when ",(0,a.jsx)(n.strong,{children:"any"})," of them changes."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["And if I have 30 variables in a class, when I update one, will it update ",(0,a.jsx)(n.strong,{children:"all"})," the variables that are in that class?"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Nope, just the ",(0,a.jsx)(n.strong,{children:"specific Widget"})," that uses that ",(0,a.jsx)(n.em,{children:"Rx"})," variable."]}),"\n",(0,a.jsxs)(n.p,{children:["So, ",(0,a.jsx)(n.strong,{children:"GetX"})," only updates the screen, when the ",(0,a.jsx)(n.em,{children:"Rx"})," variable changes it's value."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"\nfinal isOpen = false.obs;\n\n// NOTHING will happen... same value.\nvoid onButtonTap() => isOpen.value=false;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"GetX()"})," helps you when you need ",(0,a.jsx)(n.strong,{children:"granular"})," control over what's being updated."]}),"\n",(0,a.jsxs)(n.p,{children:["If you do not need ",(0,a.jsx)(n.code,{children:"unique IDs"})," , because all your variables will be modified when you perform an action, then use ",(0,a.jsx)(n.code,{children:"GetBuilder"})," ,\nbecause it's a Simple State Updater (in blocks, like ",(0,a.jsx)(n.code,{children:"setState()"})," ), made in just a few lines of code.\nIt was made simple, to have the least CPU impact, and just to fulfill a single purpose (a ",(0,a.jsx)(n.em,{children:"State"})," rebuild) and spend the minimum resources possible."]}),"\n",(0,a.jsxs)(n.p,{children:["If you need a ",(0,a.jsx)(n.strong,{children:"powerful"})," State Manager, you can't go wrong with ",(0,a.jsx)(n.strong,{children:"GetX"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["It doesn't work with variables, but ",(0,a.jsx)(n.strong,{children:"flows"}),", everything in it are ",(0,a.jsx)(n.code,{children:"Streams"})," under the hood."]}),"\n",(0,a.jsxs)(n.p,{children:["You can use ",(0,a.jsx)(n.em,{children:"rxDart"})," in conjunction with it, because everything are ",(0,a.jsx)(n.code,{children:"Streams"}),",\nyou can listen to the ",(0,a.jsx)(n.code,{children:"event"}),' of each "',(0,a.jsx)(n.em,{children:"Rx"}),' variable",\nbecause everything in it are ',(0,a.jsx)(n.code,{children:"Streams"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["It is literally a ",(0,a.jsx)(n.em,{children:"BLoC"})," approach, easier than ",(0,a.jsx)(n.em,{children:"MobX"}),", and without code generators or decorations.\nYou can turn ",(0,a.jsx)(n.strong,{children:"anything"})," into an ",(0,a.jsx)(n.em,{children:'"Observable"'})," with just a ",(0,a.jsx)(n.code,{children:".obs"})," ."]}),"\n",(0,a.jsx)(n.h3,{id:"maximum-performance",children:"Maximum performance:"}),"\n",(0,a.jsxs)(n.p,{children:["In addition to having a smart algorithm for minimal rebuilds, ",(0,a.jsx)(n.strong,{children:"GetX"})," uses comparators\nto make sure the State has changed."]}),"\n",(0,a.jsxs)(n.p,{children:["If you experience any errors in your app, and send a duplicate change of State,\n",(0,a.jsx)(n.strong,{children:"GetX"})," will ensure it will not crash."]}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.strong,{children:"GetX"})," the State only changes if the ",(0,a.jsx)(n.code,{children:"value"})," change.\nThat's the main difference between ",(0,a.jsx)(n.strong,{children:"GetX"}),", and using _ ",(0,a.jsx)(n.code,{children:"computed"})," from MobX_.\nWhen joining two ",(0,a.jsx)(n.strong,{children:"observables"}),", and one changes; the listener of that ",(0,a.jsx)(n.em,{children:"observable"})," will change as well."]}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.strong,{children:"GetX"}),", if you join two variables, ",(0,a.jsx)(n.code,{children:"GetX()"})," (similar to ",(0,a.jsx)(n.code,{children:"Observer()"})," ) will only rebuild if it implies a real change of State."]}),"\n",(0,a.jsx)(n.h3,{id:"declaring-a-reactive-variable",children:"Declaring a reactive variable"}),"\n",(0,a.jsx)(n.p,{children:'You have 3 ways to turn a variable into an "observable".'}),"\n",(0,a.jsxs)(n.p,{children:["1 - The first is using ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"Rx{Type}"})}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// initial value is recommended, but not mandatory\nfinal name = RxString('');\nfinal isLogged = RxBool(false);\nfinal count = RxInt(0);\nfinal balance = RxDouble(0.0);\nfinal items = RxList<String>([]);\nfinal myMap = RxMap<String, int>({});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["2 - The second is to use ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"Rx"})})," and use Darts Generics, ",(0,a.jsx)(n.code,{children:"Rx<Type>"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"final name = Rx<String>('');\nfinal isLogged = Rx<Bool>(false);\nfinal count = Rx<Int>(0);\nfinal balance = Rx<Double>(0.0);\nfinal number = Rx<Num>(0);\nfinal items = Rx<List<String>>([]);\nfinal myMap = Rx<Map<String, int>>({});\n\n// Custom classes - it can be any class, literally\nfinal user = Rx<User>();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["3 - The third, more practical, easier and preferred approach, just add ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:".obs"})})," as a property of your ",(0,a.jsx)(n.code,{children:"value"})," :"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"final name = ''.obs;\nfinal isLogged = false.obs;\nfinal count = 0.obs;\nfinal balance = 0.0.obs;\nfinal number = 0.obs;\nfinal items = <String>[].obs;\nfinal myMap = <String, int>{}.obs;\n\n// Custom classes - it can be any class, literally\nfinal user = User().obs;\n"})}),"\n",(0,a.jsx)(n.h5,{id:"having-a-reactive-state-is-easy",children:"Having a reactive state, is easy."}),"\n",(0,a.jsxs)(n.p,{children:["As we know, ",(0,a.jsx)(n.em,{children:"Dart"})," is now heading towards ",(0,a.jsx)(n.em,{children:"null safety"}),".\nTo be prepared, from now on, you should always start your ",(0,a.jsx)(n.em,{children:"Rx"})," variables with an ",(0,a.jsx)(n.strong,{children:"initial value"}),"."]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Transforming a variable into an ",(0,a.jsx)(n.em,{children:"observable"})," + ",(0,a.jsx)(n.em,{children:"initial value"})," with ",(0,a.jsx)(n.strong,{children:"GetX"})," is the simplest, and most practical approach."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['You will literally add a " ',(0,a.jsx)(n.code,{children:".obs"}),' " to the end of your variable, and ',(0,a.jsx)(n.strong,{children:"that\u2019s it"}),", you\u2019ve made it observable,\nand its ",(0,a.jsx)(n.code,{children:".value"})," , well, will be the ",(0,a.jsx)(n.em,{children:"initial value"}),")."]}),"\n",(0,a.jsx)(n.h3,{id:"using-the-values-in-the-view",children:"Using the values in the view"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// controller file\nfinal count1 = 0.obs;\nfinal count2 = 0.obs;\nint get sum => count1.value + count2.value;\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// view file\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 1 rebuild\");\n    return Text('${controller.count1.value}');\n  },\n),\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 2 rebuild\");\n    return Text('${controller.count2.value}');\n  },\n),\nGetX<Controller>(\n  builder: (controller) {\n    print(\"count 3 rebuild\");\n    return Text('${controller.sum}');\n  },\n),\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If we increment ",(0,a.jsx)(n.code,{children:"count1.value++"})," , it will print:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"count 1 rebuild"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"count 3 rebuild"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["because ",(0,a.jsx)(n.code,{children:"count1"})," has a value of ",(0,a.jsx)(n.code,{children:"1"})," , and ",(0,a.jsx)(n.code,{children:"1 + 0 = 1"})," , changing the ",(0,a.jsx)(n.code,{children:"sum"})," getter value."]}),"\n",(0,a.jsxs)(n.p,{children:["If we change ",(0,a.jsx)(n.code,{children:"count2.value++"})," , it will print:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"count 2 rebuild"})}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"count 3 rebuild"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["because ",(0,a.jsx)(n.code,{children:"count2.value"})," changed, and the result of the ",(0,a.jsx)(n.code,{children:"sum"})," is now ",(0,a.jsx)(n.code,{children:"2"})," ."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["NOTE: By default, the very first event will rebuild the widget, even if it is the same ",(0,a.jsx)(n.code,{children:"value"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This behavior exists due to Boolean variables."}),"\n",(0,a.jsx)(n.p,{children:"Imagine you did this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"var isLogged = false.obs;\n"})}),"\n",(0,a.jsxs)(n.p,{children:['And then, you checked if a user is "logged in" to trigger an event in ',(0,a.jsx)(n.code,{children:"ever"})," ."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"@override\nonInit() async {\n  ever(isLogged, fireRoute);\n  isLogged.value = await Preferences.hasToken();\n}\n\nfireRoute(logged) {\n  if (logged) {\n   Get.off(Home());\n  } else {\n   Get.off(Login());\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["if ",(0,a.jsx)(n.code,{children:"hasToken"})," was ",(0,a.jsx)(n.code,{children:"false"})," , there would be no change to ",(0,a.jsx)(n.code,{children:"isLogged"})," , so ",(0,a.jsx)(n.code,{children:"ever()"})," would never be called.\nTo avoid this type of behavior, the first change to an ",(0,a.jsx)(n.em,{children:"observable"})," will always trigger an event,\neven if it contains the same ",(0,a.jsx)(n.code,{children:".value"})," ."]}),"\n",(0,a.jsxs)(n.p,{children:["You can remove this behavior if you want, using:\n",(0,a.jsx)(n.code,{children:"isLogged.firstRebuild = false;"})]}),"\n",(0,a.jsx)(n.h3,{id:"conditions-to-rebuild",children:"Conditions to rebuild"}),"\n",(0,a.jsx)(n.p,{children:"In addition, Get provides refined state control. You can condition an event (such as adding an object to a list), on a certain condition."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// First parameter: condition, must return true or false.\n// Second parameter: the new value to apply if the condition is true.\nlist.addIf(item < limit, item);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Without decorations, without a code generator, without complications ","\ud83d\ude04"]}),"\n",(0,a.jsx)(n.p,{children:"Do you know Flutter's counter app? Your Controller class might look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class CountController extends GetxController {\n  final count = 0.obs;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"With a simple:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"controller.count.value++\n"})}),"\n",(0,a.jsx)(n.p,{children:"You could update the counter variable in your UI, regardless of where it is stored."}),"\n",(0,a.jsx)(n.h3,{id:"where-obs-can-be-used",children:"Where .obs can be used"}),"\n",(0,a.jsx)(n.p,{children:"You can transform anything on obs. Here are two ways of doing it:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"You can convert your class values to obs"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'class RxUser {\n  final name = "Camila".obs;\n  final age = 18.obs;\n}\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"or you can convert the entire class to be an observable"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'class User {\n  User({String name, int age});\n  var name;\n  var age;\n}\n\n// when instantianting:\nfinal user = User(name: "Camila", age: 18).obs;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"note-about-lists",children:"Note about Lists"}),"\n",(0,a.jsx)(n.p,{children:"Lists are completely observable as are the objects within it. That way, if you add a value to a list, it will automatically rebuild the widgets that use it."}),"\n",(0,a.jsx)(n.p,{children:"You also don't need to use \".value\" with lists, the amazing dart api allowed us to remove that.\nUnfortunaly primitive types like String and int cannot be extended, making the use of .value mandatory, but that won't be a problem if you work with gets and setters for these."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// On the controller\nfinal String title = 'User Info:'.obs\nfinal list = List<User>().obs;\n\n// on the view\nText(controller.title.value), // String need to have .value in front of it\nListView.builder (\n  itemCount: controller.list.length // lists don't need it\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"When you are making your own classes observable, there is a different way to update them:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// on the model file\n// we are going to make the entire class observable instead of each attribute\nclass User() {\n  User({this.name = '', this.age = 0});\n  String name;\n  int age;\n}\n\n// on the controller file\nfinal user = User().obs;\n// when you need to update the user variable:\nuser.update( (user) { // this parameter is the class itself that you want to update\nuser.name = 'Jonny';\nuser.age = 18;\n});\n// an alternative way of update the user variable:\nuser(User(name: 'Jo\xe3o', age: 35));\n\n// on view:\nObx(()=> Text(\"Name ${user.value.name}: Age: ${user.value.age}\"))\n// you can also access the model values without the .value:\nuser().name; // notice that is the user variable, not the class (variable has lowercase u)\n"})}),"\n",(0,a.jsx)(n.p,{children:'You don\'t have to work with sets if you don\'t want to. you can use the "assign \'and" assignAll "api.\nThe "assign" api will clear your list, and add a single object that you want to start there.\nThe "assignAll" api will clear the existing list and add any iterable objects that you inject into it.'}),"\n",(0,a.jsx)(n.h3,{id:"why-i-have-to-use-value",children:"Why i have to use .value"}),"\n",(0,a.jsxs)(n.p,{children:["We could remove the obligation to use 'value' to ",(0,a.jsx)(n.code,{children:"String"})," and ",(0,a.jsx)(n.code,{children:"int"})," with a simple decoration and code generator, but the purpose of this library is precisely avoid external dependencies. We want to offer an environment ready for programming, involving the essentials (management of routes, dependencies and states), in a simple, lightweight and performant way, without a need of an external package."]}),"\n",(0,a.jsx)(n.p,{children:"You can literally add 3 letters to your pubspec (get) and a colon and start programming. All solutions included by default, from route management to state management, aim at ease, productivity and performance."}),"\n",(0,a.jsx)(n.p,{children:"The total weight of this library is less than that of a single state manager, even though it is a complete solution, and that is what you must understand."}),"\n",(0,a.jsxs)(n.p,{children:["If you are bothered by ",(0,a.jsx)(n.code,{children:".value"}),' , and like a code generator, MobX is a great alternative, and you can use it in conjunction with Get. For those who want to add a single dependency in pubspec and start programming without worrying about the version of a package being incompatible with another, or if the error of a state update is coming from the state manager or dependency, or still, do not want to worrying about the availability of controllers, whether literally "just programming", get is just perfect.']}),"\n",(0,a.jsx)(n.p,{children:"If you have no problem with the MobX code generator, or have no problem with the BLoC boilerplate, you can simply use Get for routes, and forget that it has state manager. Get SEM and RSM were born out of necessity, my company had a project with more than 90 controllers, and the code generator simply took more than 30 minutes to complete its tasks after a Flutter Clean on a reasonably good machine, if your project it has 5, 10, 15 controllers, any state manager will supply you well. If you have an absurdly large project, and code generator is a problem for you, you have been awarded this solution."}),"\n",(0,a.jsx)(n.p,{children:"Obviously, if someone wants to contribute to the project and create a code generator, or something similar, I will link in this readme as an alternative, my need is not the need for all devs, but for now I say, there are good solutions that already do that, like MobX."}),"\n",(0,a.jsx)(n.h3,{id:"obx",children:"Obx()"}),"\n",(0,a.jsxs)(n.p,{children:["Typing in Get using Bindings is unnecessary. you can use the Obx widget instead of GetX which only receives the anonymous function that creates a widget.\nObviously, if you don't use a type, you will need to have an instance of your controller to use the variables, or use ",(0,a.jsx)(n.code,{children:"Get.find<Controller>()"})," .value or Controller.to.value to retrieve the value."]}),"\n",(0,a.jsx)(n.h3,{id:"workers",children:"Workers"}),"\n",(0,a.jsx)(n.p,{children:"Workers will assist you, triggering specific callbacks when an event occurs."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'/// Called every time `count1` changes.\never(count1, (_) => print("$_ has been changed"));\n\n/// Called only first time the variable $_ is changed\nonce(count1, (_) => print("$_ was changed once"));\n\n/// Anti DDos - Called every time the user stops typing for 1 second, for example.\ndebounce(count1, (_) => print("debouce$_"), time: Duration(seconds: 1));\n\n/// Ignore all changes within 1 second.\ninterval(count1, (_) => print("interval $_"), time: Duration(seconds: 1));\n'})}),"\n",(0,a.jsxs)(n.p,{children:["All workers (except ",(0,a.jsx)(n.code,{children:"debounce"})," ) have a ",(0,a.jsx)(n.code,{children:"condition"})," named parameter, which can be a ",(0,a.jsx)(n.code,{children:"bool"})," or a callback that returns a ",(0,a.jsx)(n.code,{children:"bool"})," .\nThis ",(0,a.jsx)(n.code,{children:"condition"})," defines when the ",(0,a.jsx)(n.code,{children:"callback"})," function executes."]}),"\n",(0,a.jsxs)(n.p,{children:["All workers returns a ",(0,a.jsx)(n.code,{children:"Worker"})," instance, that you can use to cancel ( via ",(0,a.jsx)(n.code,{children:"dispose()"})," ) the worker."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"ever"})})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["is called every time the ",(0,a.jsx)(n.em,{children:"Rx"})," variable emits a new value."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"everAll"})})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Much like ",(0,a.jsx)(n.code,{children:"ever"})," , but it takes a ",(0,a.jsx)(n.code,{children:"List"})," of ",(0,a.jsx)(n.em,{children:"Rx"})," values Called every time its variable is changed. That's it."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"once"})})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"'once' is called only the first time the variable has been changed."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"debounce"})})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:'\'debounce\' is very useful in search functions, where you only want the API to be called when the user finishes typing. If the user types "Jonny", you will have 5 searches in the APIs, by the letter J, o, n, n, and y. With Get this does not happen, because you will have a "debounce" Worker that will only be triggered at the end of typing.'}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"interval"})})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"'interval' is different from the debouce. debouce if the user makes 1000 changes to a variable within 1 second, he will send only the last one after the stipulated timer (the default is 800 milliseconds). Interval will instead ignore all user actions for the stipulated period. If you send events for 1 minute, 1000 per second, debounce will only send you the last one, when the user stops strafing events. interval will deliver events every second, and if set to 3 seconds, it will deliver 20 events that minute. This is recommended to avoid abuse, in functions where the user can quickly click on something and get some advantage (imagine that the user can earn coins by clicking on something, if he clicked 300 times in the same minute, he would have 300 coins, using interval, you can set a time frame for 3 seconds, and even then clicking 300 or a thousand times, the maximum he would get in 1 minute would be 20 coins, clicking 300 or 1 million times). The debounce is suitable for anti-DDos, for functions like search where each change to onChange would cause a query to your api. Debounce will wait for the user to stop typing the name, to make the request. If it were used in the coin scenario mentioned above, the user would only win 1 coin, because it is only executed, when the user \"pauses\" for the established time."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"NOTE: Workers should always be used when starting a Controller or Class, so it should always be on onInit (recommended), Class constructor, or the initState of a StatefulWidget (this practice is not recommended in most cases, but it shouldn't have any side effects)."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"simple-state-manager",children:"Simple State Manager"}),"\n",(0,a.jsx)(n.p,{children:"Get has a state manager that is extremely light and easy, which does not use ChangeNotifier, will meet the need especially for those new to Flutter, and will not cause problems for large applications."}),"\n",(0,a.jsx)(n.p,{children:'GetBuilder is aimed precisely at multiple state control. Imagine that you added 30 products to a cart, you click delete one, at the same time that the list is updated, the price is updated and the badge in the shopping cart is updated to a smaller number. This type of approach makes GetBuilder killer, because it groups states and changes them all at once without any "computational logic" for that. GetBuilder was created with this type of situation in mind, since for ephemeral change of state, you can use setState and you would not need a state manager for this.'}),"\n",(0,a.jsx)(n.p,{children:'That way, if you want an individual controller, you can assign IDs for that, or use GetX. This is up to you, remembering that the more "individual" widgets you have, the more the performance of GetX will stand out, while the performance of GetBuilder should be superior, when there is multiple change of state.'}),"\n",(0,a.jsx)(n.h3,{id:"advantages-1",children:"Advantages"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Update only the required widgets."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Does not use changeNotifier, it is the state manager that uses less memory (close to 0mb)."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Forget StatefulWidget! With Get you will never need it. With the other state managers, you will probably have to use a StatefulWidget to get the instance of your Provider, BLoC, MobX Controller, etc. But have you ever stopped to think that your appBar, your scaffold, and most of the widgets that are in your class are stateless? So why save the state of an entire class, if you can only save the state of the Widget that is stateful? Get solves that, too. Create a Stateless class, make everything stateless. If you need to update a single component, wrap it with GetBuilder, and its state will be maintained."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Organize your project for real! Controllers must not be in your UI, place your TextEditController, or any controller you use within your Controller class."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Do you need to trigger an event to update a widget as soon as it is rendered? GetBuilder has the property "initState", just like StatefulWidget, and you can call events from your controller, directly from it, no more events being placed in your initState.'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Do you need to trigger an action like closing streams, timers and etc? GetBuilder also has the dispose property, where you can call events as soon as that widget is destroyed."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Use streams only if necessary. You can use your StreamControllers inside your controller normally, and use StreamBuilder also normally, but remember, a stream reasonably consumes memory, reactive programming is beautiful, but you shouldn't abuse it. 30 streams open simultaneously can be worse than changeNotifier (and changeNotifier is very bad)."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Update widgets without spending ram for that. Get stores only the GetBuilder creator ID, and updates that GetBuilder when necessary. The memory consumption of the get ID storage in memory is very low even for thousands of GetBuilders. When you create a new GetBuilder, you are actually sharing the state of GetBuilder that has a creator ID. A new state is not created for each GetBuilder, which saves A LOT OF ram for large applications. Basically your application will be entirely Stateless, and the few Widgets that will be Stateful (within GetBuilder) will have a single state, and therefore updating one will update them all. The state is just one."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Get is omniscient and in most cases it knows exactly the time to take a controller out of memory. You should not worry about when to dispose of a controller, Get knows the best time to do this."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"// Create controller class and extends GetxController\nclass Controller extends GetxController {\n  int counter = 0;\n  void increment() {\n    counter++;\n    update(); // use update() to update counter variable on UI when increment be called\n  }\n}\n// On your Stateless/Stateful class, use GetBuilder to update Text when increment be called\nGetBuilder<Controller>(\n  init: Controller(), // INIT IT ONLY THE FIRST TIME\n  builder: (_) => Text(\n    '${_.counter}',\n  ),\n)\n//Initialize your controller only the first time. The second time you are using ReBuilder for the same controller, do not use it again. Your controller will be automatically removed from memory as soon as the widget that marked it as 'init' is deployed. You don't have to worry about that, Get will do it automatically, just make sure you don't start the same controller twice.\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Done!"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"You have already learned how to manage states with Get."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Note: You may want a larger organization, and not use the init property. For that, you can create a class and extends Binding class, and within it mention the controllers that will be created within that route. Controllers will not be created at that time, on the contrary, this is just a statement, so that the first time you use a Controller, Get will know where to look. Get will remain lazyLoad, and will continue to dispose Controllers when they are no longer needed. See the pub.dev example to see how it works."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"If you navigate many routes and need data that was in your previously used controller, you just need to use GetBuilder Again (with no init):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class OtherClass extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GetBuilder<Controller>(\n          builder: (s) => Text('${s.counter}'),\n        ),\n      ),\n    );\n  }\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If you need to use your controller in many other places, and outside of GetBuilder, just create a get in your controller and have it easily. (or use ",(0,a.jsx)(n.code,{children:"Get.find<Controller>()"})," )"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class Controller extends GetxController {\n\n  /// You do not need that. I recommend using it just for ease of syntax.\n  /// with static method: Controller.to.increment();\n  /// with no static method: Get.find<Controller>().increment();\n  /// There is no difference in performance, nor any side effect of using either syntax. Only one does not need the type, and the other the IDE will autocomplete it.\n  static Controller get to => Get.find(); // add this line\n\n  int counter = 0;\n  void increment() {\n    counter++;\n    update();\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"And then you can access your controller directly, that way:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:'FloatingActionButton(\n  onPressed: () {\n    Controller.to.increment(),\n  } // This is incredibly simple!\n  child: Text("${Controller.to.counter}"),\n),\n'})}),"\n",(0,a.jsx)(n.p,{children:"When you press FloatingActionButton, all widgets that are listening to the 'counter' variable will be updated automatically."}),"\n",(0,a.jsx)(n.h3,{id:"how-it-handles-controllers",children:"How it handles controllers"}),"\n",(0,a.jsx)(n.p,{children:"Let's say we have this:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"Class a => Class B (has controller X) => Class C (has controller X)"})}),"\n",(0,a.jsx)(n.p,{children:"In class A the controller is not yet in memory, because you have not used it yet (Get is lazyLoad). In class B you used the controller, and it entered memory. In class C you used the same controller as in class B, Get will share the state of controller B with controller C, and the same controller is still in memory. If you close screen C and screen B, Get will automatically take controller X out of memory and free up resources, because Class a is not using the controller. If you navigate to B again, controller X will enter memory again, if instead of going to class C, you return to class A again, Get will take the controller out of memory in the same way. If class C didn't use the controller, and you took class B out of memory, no class would be using controller X and likewise it would be disposed of. The only exception that can mess with Get, is if you remove B from the route unexpectedly, and try to use the controller in C. In this case, the creator ID of the controller that was in B was deleted, and Get was programmed to remove it from memory every controller that has no creator ID. If you intend to do this, add the \"autoRemove: false\" flag to class B's GetBuilder and use adoptID = true; in class C's GetBuilder."}),"\n",(0,a.jsx)(n.h3,{id:"you-wont-need-statefulwidgets-anymore",children:"You won't need StatefulWidgets anymore"}),"\n",(0,a.jsx)(n.p,{children:"Using StatefulWidgets means storing the state of entire screens unnecessarily, even because if you need to minimally rebuild a widget, you will embed it in a Consumer/Observer/BlocProvider/GetBuilder/GetX/Obx, which will be another StatefulWidget.\nThe StatefulWidget class is a class larger than StatelessWidget, which will allocate more RAM, and this may not make a significant difference between one or two classes, but it will most certainly do when you have 100 of them!\nUnless you need to use a mixin, like TickerProviderStateMixin, it will be totally unnecessary to use a StatefulWidget with Get."}),"\n",(0,a.jsx)(n.p,{children:"You can call all methods of a StatefulWidget directly from a GetBuilder.\nIf you need to call initState() or dispose() method for example, you can call them directly;"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  initState: (_) => Controller.to.fetchApi(),\n  dispose: (_) => Controller.to.closeStreams(),\n  builder: (s) => Text('${s.username}'),\n),\n"})}),"\n",(0,a.jsx)(n.p,{children:"A much better approach than this is to use the onInit() and onClose() method directly from your controller."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"@override\nvoid onInit() {\n  fetchApi();\n  super.onInit();\n}\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"NOTE: If you want to start a method at the moment the controller is called for the first time, you DON'T NEED to use constructors for this, in fact, using a performance-oriented package like Get, this borders on bad practice, because it deviates from the logic in which the controllers are created or allocated (if you create an instance of this controller, the constructor will be called immediately, you will be populating a controller before it is even used, you are allocating memory without it being in use, this definitely hurts the principles of this library). The onInit() methods; and onClose(); were created for this, they will be called when the Controller is created, or used for the first time, depending on whether you are using Get.lazyPut or not. If you want, for example, to make a call to your API to populate data, you can forget about the old-fashioned method of initState/dispose, just start your call to the api in onInit, and if you need to execute any command like closing streams, use the onClose() for that."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"why-it-exists",children:"Why it exists"}),"\n",(0,a.jsx)(n.p,{children:"The purpose of this package is precisely to give you a complete solution for navigation of routes, management of dependencies and states, using the least possible dependencies, with a high degree of decoupling. Get engages all high and low level Flutter APIs within itself, to ensure that you work with the least possible coupling. We centralize everything in a single package, to ensure that you don't have any kind of coupling in your project. That way, you can put only widgets in your view, and leave the part of your team that works with the business logic free, to work with the business logic without depending on any element of the View. This provides a much cleaner working environment, so that part of your team works only with widgets, without worrying about sending data to your controller, and part of your team works only with the business logic in its breadth, without depending on no element of the view."}),"\n",(0,a.jsx)(n.p,{children:"So to simplify this:\nYou don't need to call methods in initState and send them by parameter to your controller, nor use your controller constructor for that, you have the onInit() method that is called at the right time for you to start your services.\nYou do not need to call the device, you have the onClose() method that will be called at the exact moment when your controller is no longer needed and will be removed from memory. That way, leave views for widgets only, refrain from any kind of business logic from it."}),"\n",(0,a.jsx)(n.p,{children:'Do not call a dispose method inside GetxController, it will not do anything, remember that the controller is not a Widget, you should not "dispose" it, and it will be automatically and intelligently removed from memory by Get. If you used any stream on it and want to close it, just insert it into the close method. Example:'}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class Controller extends GetxController {\n  StreamController<User> user = StreamController<User>();\n  StreamController<String> name = StreamController<String>();\n\n  /// close stream = onClose method, not dispose.\n  @override\n  void onClose() {\n    user.close();\n    name.close();\n    super.onClose();\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Controller life cycle:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"onInit() where it is created."}),"\n",(0,a.jsx)(n.li,{children:"onClose() where it is closed to make any changes in preparation for the delete method"}),"\n",(0,a.jsx)(n.li,{children:"deleted: you do not have access to this API because it is literally removing the controller from memory. It is literally deleted, without leaving any trace."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"other-ways-of-using-it",children:"Other ways of using it"}),"\n",(0,a.jsx)(n.p,{children:"You can use Controller instance directly on GetBuilder value:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  init: Controller(),\n  builder: (value) => Text(\n    '${value.counter}', //here\n  ),\n),\n"})}),"\n",(0,a.jsx)(n.p,{children:"You may also need an instance of your controller outside of your GetBuilder, and you can use these approaches to achieve this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class Controller extends GetxController {\n  static Controller get to => Get.find();\n[...]\n}\n// on you view:\nGetBuilder<Controller>(  \n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Controller.to.counter}', //here\n  )\n),\n"})}),"\n",(0,a.jsx)(n.p,{children:"or"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class Controller extends GetxController {\n // static Controller get to => Get.find(); // with no static get\n[...]\n}\n// on stateful/stateless class\nGetBuilder<Controller>(  \n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Get.find<Controller>().counter}', //here\n  ),\n),\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'You can use "non-canonical" approaches to do this. If you are using some other dependency manager, like get_it, modular, etc., and just want to deliver the controller instance, you can do this:'}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Controller controller = Controller();\n[...]\nGetBuilder<Controller>(\n  init: controller, //here\n  builder: (_) => Text(\n    '${controller.counter}', // here\n  ),\n),\n\n"})}),"\n",(0,a.jsx)(n.h3,{id:"unique-ids",children:"Unique IDs"}),"\n",(0,a.jsx)(n.p,{children:"If you want to refine a widget's update control with GetBuilder, you can assign them unique IDs:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"GetBuilder<Controller>(\n  id: 'text'\n  init: Controller(), // use it only first time on each controller\n  builder: (_) => Text(\n    '${Get.find<Controller>().counter}', //here\n  ),\n),\n"})}),"\n",(0,a.jsx)(n.p,{children:"And update it this form:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"update(['text']);\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also impose conditions for the update:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"update(['text'], counter < 10);\n"})}),"\n",(0,a.jsx)(n.p,{children:"GetX does this automatically and only reconstructs the widget that uses the exact variable that was changed, if you change a variable to the same as the previous one and that does not imply a change of state , GetX will not rebuild the widget to save memory and CPU cycles (3 is being displayed on the screen, and you change the variable to 3 again. In most state managers, this will cause a new rebuild, but with GetX the widget will only is rebuilt again, if in fact his state has changed)."}),"\n",(0,a.jsx)(n.h2,{id:"mixing-the-two-state-managers",children:"Mixing the two state managers"}),"\n",(0,a.jsx)(n.p,{children:'Some people opened a feature request, as they wanted to use only one type of reactive variable, and the other mechanics, and needed to insert an Obx into a GetBuilder for this. Thinking about it MixinBuilder was created. It allows both reactive changes by changing ".obs" variables, and mechanical updates via update(). However, of the 4 widgets he is the one that consumes the most resources, since in addition to having a Subscription to receive change events from his children, he subscribes to the update method of his controller.'}),"\n",(0,a.jsx)(n.p,{children:'Extending GetxController is important, as they have life cycles, and can "start" and "end" events in their onInit() and onClose() methods. You can use any class for this, but I strongly recommend you use the GetxController class to place your variables, whether they are observable or not.'}),"\n",(0,a.jsx)(n.h2,{id:"statemixin",children:"StateMixin"}),"\n",(0,a.jsxs)(n.p,{children:["Another way to handle your ",(0,a.jsx)(n.code,{children:"UI"})," state is use the ",(0,a.jsx)(n.code,{children:"StateMixin<T>"})," .\nTo implement it, use the ",(0,a.jsx)(n.code,{children:"with"})," to add the ",(0,a.jsx)(n.code,{children:"StateMixin<T>"}),"\nto your controller which allows a T model."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class Controller extends GetController with StateMixin<User>{}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"change()"})," method change the State whenever we want.\nJust pass the data and the status in this way:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"change(data, status: RxStatus.success());\n"})}),"\n",(0,a.jsx)(n.p,{children:"RxStatus allow these status:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"RxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n"})}),"\n",(0,a.jsx)(n.p,{children:"To represent it in the UI, use:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"getbuilder-vs-getx-vs-obx-vs-mixinbuilder",children:"GetBuilder vs GetX vs Obx vs MixinBuilder"}),"\n",(0,a.jsx)(n.p,{children:"In a decade working with programming I was able to learn some valuable lessons."}),"\n",(0,a.jsx)(n.p,{children:'My first contact with reactive programming was so "wow, this is incredible" and in fact reactive programming is incredible.\nHowever, it is not suitable for all situations. Often all you need is to change the state of 2 or 3 widgets at the same time, or an ephemeral change of state, in which case reactive programming is not bad, but it is not appropriate.'}),"\n",(0,a.jsx)(n.p,{children:"Reactive programming has a higher RAM consumption that can be compensated for by the individual workflow, which will ensure that only one widget is rebuilt and when necessary, but creating a list with 80 objects, each with several streams is not a good one idea. Open the dart inspect and check how much a StreamBuilder consumes, and you'll understand what I'm trying to tell you."}),"\n",(0,a.jsx)(n.p,{children:"With that in mind, I created the simple state manager. It is simple, and that is exactly what you should demand from it: updating state in blocks in a simple way, and in the most economical way."}),"\n",(0,a.jsx)(n.p,{children:"GetBuilder is very economical in RAM, and there is hardly a more economical approach than him (at least I can't imagine one, if it exists, please let us know)."}),"\n",(0,a.jsx)(n.p,{children:"However, GetBuilder is still a mechanical state manager, you need to call update() just like you would need to call Provider's notifyListeners()."}),"\n",(0,a.jsx)(n.p,{children:"There are other situations where reactive programming is really interesting, and not working with it is the same as reinventing the wheel. With that in mind, GetX was created to provide everything that is most modern and advanced in a state manager. It updates only what is necessary and when necessary, if you have an error and send 300 state changes simultaneously, GetX will filter and update the screen only if the state actually changes."}),"\n",(0,a.jsx)(n.p,{children:"GetX is still more economical than any other reactive state manager, but it consumes a little more RAM than GetBuilder. Thinking about it and aiming to maximize the consumption of resources that Obx was created. Unlike GetX and GetBuilder, you will not be able to initialize a controller inside an Obx, it is just a Widget with a StreamSubscription that receives change events from your children, that's all. It is more economical than GetX, but loses to GetBuilder, which was to be expected, since it is reactive, and GetBuilder has the most simplistic approach that exists, of storing a widget's hashcode and its StateSetter. With Obx you don't need to write your controller type, and you can hear the change from multiple different controllers, but it needs to be initialized before, either using the example approach at the beginning of this readme, or using the Bindings class."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>s});var a=t(7294);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);